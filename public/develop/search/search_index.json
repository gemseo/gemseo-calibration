{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#gemseo-calibration","title":"gemseo-calibration","text":""},{"location":"#overview","title":"Overview","text":"<p>Capability to calibrate GEMSEO disciplines from data.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install the latest stable version with <code>pip install gemseo-calibration</code>.</p> <p>Install the development version with <code>pip install gemseo-calibration@git+https://gitlab.com/gemseo/dev/gemseo-calibration.git@develop</code>.</p> <p>See pip for more information.</p>"},{"location":"#bugs-and-questions","title":"Bugs and questions","text":"<p>Please use the gitlab issue tracker to submit bugs or questions.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>See the contributing section of GEMSEO.</p>"},{"location":"#contributors","title":"Contributors","text":"<ul> <li>Matthias De Lozzo</li> <li>Antoine DECHAUME</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes of this project will be documented here.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#version-202-december-2023","title":"Version 2.0.2 (December 2023)","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Support for Python 3.11.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Support for Python 3.8.</li> </ul>"},{"location":"changelog/#version-201-september-2023","title":"Version 2.0.1 (September 2023)","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Compatibility with recent versions of NumPy.</li> </ul>"},{"location":"changelog/#version-200-june-2023","title":"Version 2.0.0 (June 2023)","text":"<p>Update to GEMSEO 5.</p>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Data are <code>dict[str, ndarray]</code> objects as     <code>{variable_name: variable_values}</code> instead of     <code>~gemseo.datasets.dataset.Dataset</code>.</li> <li>Use <code>\"\"</code> as empty value of <code>str</code> and <code>str | Path</code> arguments, instead     of <code>\"None\"</code>.</li> <li><code>.CalibrationMeasure</code>: the type of     <code>f_type</code> is     <code>~gemseo.core.mdofunctions.mdo_function.MDOFunction.FunctionType</code>{.interpreted-text     role=\"attr\"}.</li> </ul>"},{"location":"changelog/#version-100-july-2022","title":"Version 1.0.0 (July 2022)","text":"<p>First release.</p>"},{"location":"credits/","title":"Credits","text":""},{"location":"credits/#exec-1--credits","title":"Credits","text":"<p>The developers thank all the open source libraries making <code>gemseo-calibration</code> possible.</p>"},{"location":"credits/#exec-1--external-dependencies","title":"External Dependencies","text":"<p><code>gemseo-calibration</code> depends on software with compatible licenses that are listed below.</p> Project License <code>Python</code> Python Software License <code>gemseo</code> GNU Lesser General Public License v3 <code>matplotlib</code> Python Software Foundation License <code>numpy</code> BSD License"},{"location":"credits/#exec-1--external-applications","title":"External applications","text":"<p>Some external applications are used by <code>gemseo-calibration</code>, but not linked with the application, for testing, documentation generation, training or example purposes.</p> Project License <code>black</code> MIT <code>commitizen</code> MIT License <code>covdefaults</code> MIT License <code>docformatter</code> MIT License <code>griffe-inherited-docstrings</code> ISC <code>insert-license</code> MIT <code>markdown-exec</code> ISC <code>mike</code> BSD-3-Clause <code>mkdocs-bibtex</code> BSD-3-Clause-LBNL <code>mkdocs-gallery</code> BSD 3-Clause <code>mkdocs-gen-files</code> MIT License <code>mkdocs-include-markdown-plugin</code> Apache Software License <code>mkdocs-literate-nav</code> MIT License <code>mkdocs-material</code> MIT License <code>mkdocs-section-index</code> MIT License <code>mkdocstrings</code> ISC <code>pre-commit</code> MIT License <code>pygrep-hooks</code> MIT <code>pytest</code> MIT License <code>pytest-cov</code> MIT License <code>pytest-xdist</code> MIT License <code>ruff</code> MIT License <code>setuptools</code> MIT License <code>setuptools-scm</code> MIT License"},{"location":"licenses/","title":"Licenses","text":""},{"location":"licenses/#licenses","title":"Licenses","text":""},{"location":"licenses/#gnu-lgpl-v30","title":"GNU LGPL v3.0","text":"<p>The <code>gemseo-calibration</code> source code is distributed under the GNU LGPL v3.0 license. <pre><code>Copyright 2021 IRT Saint Exup\u00e9ry, https://www.irt-saintexupery.com\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense version 3 as published by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with this program; if not, write to the Free Software Foundation,\nInc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n</code></pre></p>"},{"location":"licenses/#bsd-0-clause","title":"BSD 0-Clause","text":"<p>The <code>gemseo-calibration</code> examples are distributed under the BSD 0-Clause <pre><code>Copyright 2021 IRT Saint Exup\u00e9ry, https://www.irt-saintexupery.com\n\nThis work is licensed under a BSD 0-Clause License.\n\nPermission to use, copy, modify, and/or distribute this software\nfor any purpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL\nWARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL\nTHE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,\nOR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING\nFROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\nNEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\nWITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n</code></pre></p>"},{"location":"licenses/#cc-by-sa-40","title":"CC BY-SA 4.0","text":"<p>The <code>gemseo-calibration</code> documentation is distributed under the CC BY-SA 4.0 license. <pre><code>Copyright 2021 IRT Saint Exup\u00e9ry, https://www.irt-saintexupery.com\n\nThis work is licensed under the Creative Commons Attribution-ShareAlike 4.0\nInternational License. To view a copy of this license, visit\nhttp://creativecommons.org/licenses/by-sa/4.0/ or send a letter to Creative\nCommons, PO Box 1866, Mountain View, CA 94042, USA.\n</code></pre></p>"},{"location":"generated/examples/calibration/","title":"Index","text":""},{"location":"generated/examples/calibration/#calibration","title":"Calibration","text":"<p>Update the parameters of a discipline from data.</p> <p> Calibration scenario. </p> <p> Calibration scenario. </p> <p> Calibration scenario. </p> <p> Calibration scenario with missing values. </p> <p> Calibration scenario with a mesh-based output. </p> <p> Calibration scenario with noised observations. </p> <p> Download all examples in Python source code: calibration_python.zip</p> <p> Download all examples in Jupyter notebooks: calibration_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/calibration/mg_execution_times/","title":"Computation times","text":"<p>00:20.646 total execution time for generated_examples_calibration files:</p> <p>+-------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_calibration_1param (docs/examples/calibration/plot_calibration_1param.py)                                        | 00:07.905 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_calibration_with_noise (docs/examples/calibration/plot_calibration_with_noise.py)                            | 00:03.185 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_calibration_constraint (docs/examples/calibration/plot_calibration_constraint.py)                            | 00:03.161 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_calibration_with_mesh (docs/examples/calibration/plot_calibration_with_mesh.py)                               | 00:02.501 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_calibration (docs/examples/calibration/plot_calibration.py)                                                             | 00:02.389 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_calibration_with_missing_values (docs/examples/calibration/plot_calibration_with_missing_values.py) | 00:01.504 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/examples/calibration/plot_calibration/","title":"Plot calibration","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/calibration/plot_calibration/#calibration-scenario","title":"Calibration scenario.","text":"<pre><code>from __future__ import annotations\n\nfrom gemseo.algos.parameter_space import ParameterSpace\nfrom gemseo.disciplines.analytic import AnalyticDiscipline\nfrom numpy import array\n\nfrom gemseo_calibration.scenario import CalibrationMeasure\nfrom gemseo_calibration.scenario import CalibrationScenario\n</code></pre> <p>Let us consider a function \\(f(x)=[ax,bx]\\) from \\(\\mathbb{R}\\) to \\(\\mathbb{R}^2\\):</p> <pre><code>model = AnalyticDiscipline({\"y\": \"a*x\", \"z\": \"b*x\"}, name=\"model\")\n</code></pre> <p>This is a model of our reference data source, which a kind of oracle providing input-output data without the mathematical relationship behind it:</p> <pre><code>reference = AnalyticDiscipline({\"y\": \"2*x\", \"z\": \"3*x\"}, name=\"reference\")\n</code></pre> <p>However in this pedagogical example, the mathematical relationship is known and we can see that the parameters \\(a\\) and \\(b\\) must be equal to 2 and 3 respectively so that the model and the reference are identical.</p> <p>In the following, we will try to find these values from several information sources.</p> <p>Firstly, we have a prior information about the parameters, that is \\([a,b]\\in[0,10]^2\\):</p> <pre><code>prior = ParameterSpace()\nprior.add_variable(\"a\", l_b=0.0, u_b=10.0, value=0.0)\nprior.add_variable(\"b\", l_b=0.0, u_b=10.0, value=0.0)\n</code></pre> <p>Secondly, we have reference output data over the input space \\([0.,3.]\\):</p> <pre><code>reference.set_cache_policy(reference.CacheType.MEMORY_FULL)\nreference.execute({\"x\": array([1.0])})\nreference.execute({\"x\": array([2.0])})\nreference_data = reference.cache.to_dataset().to_dict_of_arrays(False)\n</code></pre> <p>From these information sources, we can build and execute a CalibrationScenario to find the value of the parameters \\(a\\) and \\(b\\) which minimizes a CalibrationMeasure taking into account the outputs \\(y\\) and \\(z\\):</p> <pre><code>control_outputs = [CalibrationMeasure(\"y\", \"MSE\"), CalibrationMeasure(\"z\", \"MSE\")]\ncalibration = CalibrationScenario(model, \"x\", control_outputs, prior)\ncalibration.execute({\n    \"algo\": \"NLOPT_COBYLA\",\n    \"reference_data\": reference_data,\n    \"max_iter\": 100,\n})\n</code></pre> <p>Out:</p> <pre><code>{'reference_data': {'x': array([[1.],\n       [2.]]), 'y': array([[2.],\n       [4.]]), 'z': array([[3.],\n       [6.]])}, 'max_iter': 100, 'algo': 'NLOPT_COBYLA'}\n</code></pre> <p>Lastly, we get the calibrated parameters:</p> <p>plot an optimization history view:</p> <pre><code>calibration.post_process(\"OptHistoryView\", save=False, show=True)\n</code></pre> <p>Out:</p> <pre><code>&lt;gemseo.post.opt_history_view.OptHistoryView object at 0x78620eafa580&gt;\n</code></pre> <p>as well as the model data versus the reference ones, before and after the calibration:</p> <pre><code>calibration.post_process(\"DataVersusModel\", output=\"z\", save=False, show=True)\n</code></pre> <p></p> <p>Out:</p> <pre><code>&lt;gemseo_calibration.post.data_versus_model.post.DataVersusModel object at 0x78620e111310&gt;\n</code></pre> <p>Total running time of the script: ( 0 minutes  2.389 seconds)</p> <p> Download Python source code: plot_calibration.py</p> <p> Download Jupyter notebook: plot_calibration.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/calibration/plot_calibration_1param/","title":"Plot calibration 1param","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/calibration/plot_calibration_1param/#calibration-scenario","title":"Calibration scenario.","text":"<pre><code>from __future__ import annotations\n\nfrom gemseo.algos.parameter_space import ParameterSpace\nfrom gemseo.disciplines.analytic import AnalyticDiscipline\nfrom numpy import array\n\nfrom gemseo_calibration.scenario import CalibrationMeasure\nfrom gemseo_calibration.scenario import CalibrationScenario\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-calibration/.tox/doc/lib64/python3.9/site-packages/gemseo/third_party/prettytable/prettytable.py:73: DeprecationWarning: invalid escape sequence \\[\n  _re = re.compile(\"\\033\\[[0-9;]*m\")\n/builds/gemseo/dev/gemseo-calibration/.tox/doc/lib64/python3.9/site-packages/gemseo/third_party/prettytable/prettytable.py:1291: DeprecationWarning: invalid escape sequence \\{\n  self.vertical_char = random.choice(\"~!@#$%^&amp;*()_+|-=\\{}[];':\\\",./;&lt;&gt;?\")\n/builds/gemseo/dev/gemseo-calibration/.tox/doc/lib64/python3.9/site-packages/gemseo/third_party/prettytable/prettytable.py:1292: DeprecationWarning: invalid escape sequence \\{\n  self.horizontal_char = random.choice(\"~!@#$%^&amp;*()_+|-=\\{}[];':\\\",./;&lt;&gt;?\")\n/builds/gemseo/dev/gemseo-calibration/.tox/doc/lib64/python3.9/site-packages/gemseo/third_party/prettytable/prettytable.py:1293: DeprecationWarning: invalid escape sequence \\{\n  self.junction_char = random.choice(\"~!@#$%^&amp;*()_+|-=\\{}[];':\\\",./;&lt;&gt;?\")\n</code></pre> <p>Let us consider a function \\(f(x)=ax\\) from \\(\\mathbb{R}\\) to \\(\\mathbb{R}\\):</p> <pre><code>model = AnalyticDiscipline({\"y\": \"a*x\"}, name=\"model\")\n</code></pre> <p>This is a model of our reference data source, which a kind of oracle providing input-output data without the mathematical relationship behind it:</p> <pre><code>reference = AnalyticDiscipline({\"y\": \"2*x\"}, name=\"reference\")\n</code></pre> <p>However in this pedagogical example, the mathematical relationship is known and we can see that the parameter \\(a\\) must be equal to 2 so that the model and the reference are identical.</p> <p>In the following, we will try to find this value from an unique observation.</p> <p>Firstly, we have a prior information about the parameters, that is \\(a\\in[0,10]\\):</p> <pre><code>prior = ParameterSpace()\nprior.add_variable(\"a\", l_b=0.0, u_b=10.0, value=0.0)\n</code></pre> <p>Secondly, we have reference output data over the input space \\([0.,3.]\\):</p> <pre><code>reference.set_cache_policy(reference.CacheType.MEMORY_FULL)\nreference.execute({\"x\": array([1.0])})\nreference_data = reference.cache.to_dataset().to_dict_of_arrays(False)\n</code></pre> <p>From this unique observation, we can build and execute a CalibrationScenario to find the value of the parameter \\(a\\) which minimizes a CalibrationMeasure taking into account the outputs \\(y\\):</p> <pre><code>calibration = CalibrationScenario(model, \"x\", CalibrationMeasure(\"y\", \"MSE\"), prior)\ncalibration.execute({\n    \"algo\": \"NLOPT_COBYLA\",\n    \"reference_data\": reference_data,\n    \"max_iter\": 100,\n})\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-calibration/.tox/doc/lib64/python3.9/site-packages/networkx/utils/backends.py:135: RuntimeWarning: networkx backend defined more than once: nx-loopback\n  backends.update(_get_backends(\"networkx.backends\"))\n\n{'reference_data': {'x': array([[1.]]), 'y': array([[2.]])}, 'max_iter': 100, 'algo': 'NLOPT_COBYLA'}\n</code></pre> <p>Lastly, we get the calibrated parameters:</p> <p>plot an optimization history view:</p> <pre><code>calibration.post_process(\"OptHistoryView\", save=False, show=True)\n</code></pre> <p>Out:</p> <pre><code>&lt;gemseo.post.opt_history_view.OptHistoryView object at 0x786211f6f670&gt;\n</code></pre> <p>as well as the model data versus the reference ones, before and after the calibration:</p> <pre><code>calibration.post_process(\"DataVersusModel\", output=\"y\", save=False, show=True)\n</code></pre> <p></p> <p>Out:</p> <pre><code>&lt;gemseo_calibration.post.data_versus_model.post.DataVersusModel object at 0x7862118cdb20&gt;\n</code></pre> <p>Total running time of the script: ( 0 minutes  7.905 seconds)</p> <p> Download Python source code: plot_calibration_1param.py</p> <p> Download Jupyter notebook: plot_calibration_1param.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/calibration/plot_calibration_constraint/","title":"Plot calibration constraint","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/calibration/plot_calibration_constraint/#calibration-scenario","title":"Calibration scenario.","text":"<pre><code>from __future__ import annotations\n\nfrom gemseo.algos.parameter_space import ParameterSpace\nfrom gemseo.disciplines.analytic import AnalyticDiscipline\nfrom numpy import array\n\nfrom gemseo_calibration.scenario import CalibrationMeasure\nfrom gemseo_calibration.scenario import CalibrationScenario\n</code></pre> <p>Let us consider a function \\(f(x)=[ax,bx]\\) from \\(\\mathbb{R}\\) to \\(\\mathbb{R}^2\\):</p> <pre><code>model = AnalyticDiscipline({\"y\": \"a*x\", \"z\": \"b*x\"}, name=\"model\")\n</code></pre> <p>This is a model of our reference data source, which a kind of oracle providing input-output data without the mathematical relationship behind it:</p> <pre><code>reference = AnalyticDiscipline({\"y\": \"2*x\", \"z\": \"3*x\"}, name=\"reference\")\n</code></pre> <p>However in this pedagogical example, the mathematical relationship is known and we can see that the parameters \\(a\\) and \\(b\\) must be equal to 2 and 3 respectively so that the model and the reference are identical.</p> <p>In the following, we will try to find these values from several information sources.</p> <p>Firstly, we have a prior information about the parameters, that is \\([a,b]\\in[0,10]^2\\):</p> <pre><code>prior = ParameterSpace()\nprior.add_variable(\"a\", l_b=0.0, u_b=10.0, value=0.0)\nprior.add_variable(\"b\", l_b=0.0, u_b=10.0, value=0.0)\n</code></pre> <p>Secondly, we have reference output data over the input space \\([0.,3.]\\):</p> <pre><code>reference.set_cache_policy(reference.CacheType.MEMORY_FULL)\nreference.execute({\"x\": array([1.0])})\nreference.execute({\"x\": array([2.0])})\nreference_data = reference.cache.to_dataset().to_dict_of_arrays(False)\n</code></pre> <p>From these information sources, we can build and execute a CalibrationScenario to find the value of the parameters \\(a\\) and \\(b\\) which minimizes a CalibrationMeasure related to the output \\(y\\) with a constraint about a CalibrationMeasure related to the output \\(z\\).</p> <pre><code>calibration = CalibrationScenario(model, \"x\", CalibrationMeasure(\"y\", \"MSE\"), prior)\ncalibration.add_constraint(CalibrationMeasure(\"z\", \"MSE\"))\ncalibration.execute({\n    \"algo\": \"NLOPT_COBYLA\",\n    \"reference_data\": reference_data,\n    \"max_iter\": 100,\n})\n</code></pre> <p>Out:</p> <pre><code>{'reference_data': {'x': array([[1.],\n       [2.]]), 'y': array([[2.],\n       [4.]]), 'z': array([[3.],\n       [6.]])}, 'max_iter': 100, 'algo': 'NLOPT_COBYLA'}\n</code></pre> <p>Lastly, we get the calibrated parameters:</p> <p>plot an optimization history view:</p> <pre><code>calibration.post_process(\"OptHistoryView\", save=False, show=True)\n</code></pre> <p>Out:</p> <pre><code>&lt;gemseo.post.opt_history_view.OptHistoryView object at 0x786213571d30&gt;\n</code></pre> <p>as well as the model data versus the reference ones, before and after the calibration:</p> <pre><code>calibration.post_process(\"DataVersusModel\", output=\"z\", save=False, show=True)\n</code></pre> <p></p> <p>Out:</p> <pre><code>&lt;gemseo_calibration.post.data_versus_model.post.DataVersusModel object at 0x78620e89ad60&gt;\n</code></pre> <p>Total running time of the script: ( 0 minutes  3.161 seconds)</p> <p> Download Python source code: plot_calibration_constraint.py</p> <p> Download Jupyter notebook: plot_calibration_constraint.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/calibration/plot_calibration_with_mesh/","title":"Plot calibration with mesh","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/calibration/plot_calibration_with_mesh/#calibration-scenario-with-a-mesh-based-output","title":"Calibration scenario with a mesh-based output.","text":"<pre><code>from __future__ import annotations\n\nfrom gemseo.algos.parameter_space import ParameterSpace\nfrom gemseo.core.discipline import MDODiscipline\nfrom numpy import array\nfrom numpy import linspace\n\nfrom gemseo_calibration.scenario import CalibrationMeasure\nfrom gemseo_calibration.scenario import CalibrationScenario\n</code></pre> <p>Let us consider a function \\(f(x)=[ax,\\gamma bx, \\gamma]\\) from \\(\\mathbb{R}\\) to \\(\\mathbb{R}^11\\) where \\(\\gamma=[0,0.25,0.5,0.75,1.]\\) plays the role of a mesh. In practice, we could imagine a model having an output related to a mesh \\(\\gamma\\) whose size and nodes would depend on the model inputs. Thus, this mesh is also an output of the model.</p> <pre><code>class Model(MDODiscipline):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.input_grammar.update_from_names([\"x\", \"a\", \"b\"])\n        self.output_grammar.update_from_names([\"y\", \"z\", \"mesh\"])\n        self.default_inputs = {\"x\": array([0.0]), \"a\": array([0.0]), \"b\": array([0.0])}\n\n    def _run(self) -&gt; None:\n        x_input = self.local_data[\"x\"]\n        a_parameter = self.local_data[\"a\"]\n        b_parameter = self.local_data[\"b\"]\n        y_output = a_parameter * x_input\n        z_mesh = linspace(0, 1, 5)\n        z_output = b_parameter * x_input[0] * z_mesh\n        self.store_local_data(y=y_output, z=z_output, mesh=z_mesh)\n</code></pre> <p>This is a model of our reference data source, which a kind of oracle providing input-output data without the mathematical relationship behind it:</p> <pre><code>class ReferenceModel(MDODiscipline):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.input_grammar.update_from_names([\"x\"])\n        self.output_grammar.update_from_names([\"y\", \"z\", \"mesh\"])\n        self.default_inputs = {\"x\": array([0.0])}\n\n    def _run(self) -&gt; None:\n        x_input = self.local_data[\"x\"]\n        y_output = 2 * x_input\n        z_mesh = linspace(0, 1, 5)\n        z_output = 3 * x_input[0] * z_mesh\n        self.store_local_data(y=y_output, z=z_output, mesh=z_mesh)\n</code></pre> <p>However in this pedagogical example, the mathematical relationship is known and we can see that the parameters \\(a\\) and \\(b\\) must be equal to 2 and 3 respectively so that the model and the reference are identical.</p> <p>In the following, we will try to find these values from several information sources.</p> <p>Firstly, we have a prior information about the parameters, that is \\([a,b]\\in[0,10]^2\\):</p> <pre><code>prior = ParameterSpace()\nprior.add_variable(\"a\", l_b=0.0, u_b=10.0, value=0.0)\nprior.add_variable(\"b\", l_b=0.0, u_b=10.0, value=0.0)\n</code></pre> <p>Secondly, we have reference output data over the input space \\([0.,3.]\\):</p> <pre><code>reference = ReferenceModel()\nreference.set_cache_policy(reference.CacheType.MEMORY_FULL)\nreference.execute({\"x\": array([1.0])})\nreference.execute({\"x\": array([2.0])})\nreference_data = reference.cache.to_dataset().to_dict_of_arrays(False)\n</code></pre> <p>From these information sources, we can build and execute a CalibrationScenario to find the values of the parameters \\(a\\) and \\(b\\) which minimizes a CalibrationMeasure taking into account the outputs \\(y\\) and \\(z\\):</p> <pre><code>model = Model()\ncontrol_outputs = [\n    CalibrationMeasure(\"y\", \"MSE\"),\n    CalibrationMeasure(\"z\", \"ISE\", \"mesh\"),\n]\ncalibration = CalibrationScenario(model, \"x\", control_outputs, prior)\ncalibration.execute({\n    \"algo\": \"NLOPT_COBYLA\",\n    \"reference_data\": reference_data,\n    \"max_iter\": 100,\n})\n</code></pre> <p>Out:</p> <pre><code>{'reference_data': {'x': array([[1.],\n       [2.]]), 'mesh': array([[0.  , 0.25, 0.5 , 0.75, 1.  ],\n       [0.  , 0.25, 0.5 , 0.75, 1.  ]]), 'y': array([[2.],\n       [4.]]), 'z': array([[0.  , 0.75, 1.5 , 2.25, 3.  ],\n       [0.  , 1.5 , 3.  , 4.5 , 6.  ]])}, 'max_iter': 100, 'algo': 'NLOPT_COBYLA'}\n</code></pre> <p>Lastly, we get the calibrated parameters:</p> <p>plot an optimization history view:</p> <pre><code>calibration.post_process(\"OptHistoryView\", save=False, show=True)\n</code></pre> <p>Out:</p> <pre><code>&lt;gemseo.post.opt_history_view.OptHistoryView object at 0x78620ec30df0&gt;\n</code></pre> <p>as well as the model data versus the reference ones, before and after the calibration:</p> <pre><code>calibration.post_process(\"DataVersusModel\", output=\"y\", save=False, show=True)\n</code></pre> <p></p> <p>Out:</p> <pre><code>&lt;gemseo_calibration.post.data_versus_model.post.DataVersusModel object at 0x78620d5a1ac0&gt;\n</code></pre> <p>Total running time of the script: ( 0 minutes  2.501 seconds)</p> <p> Download Python source code: plot_calibration_with_mesh.py</p> <p> Download Jupyter notebook: plot_calibration_with_mesh.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/calibration/plot_calibration_with_missing_values/","title":"Plot calibration with missing values","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/calibration/plot_calibration_with_missing_values/#calibration-scenario-with-missing-values","title":"Calibration scenario with missing values.","text":"<p>Out:</p> <pre><code>{'reference_data': {'index': array([[1.],\n       [2.],\n       [3.],\n       [4.]]), 'x': array([[1.],\n       [1.],\n       [2.],\n       [2.]]), 'y': array([[ 2.],\n       [nan],\n       [ 4.],\n       [nan]]), 'z': array([[nan],\n       [ 3.],\n       [nan],\n       [ 6.]])}, 'max_iter': 100, 'algo': 'NLOPT_COBYLA'}\n</code></pre> <p></p> <pre><code>from __future__ import annotations\n\nfrom gemseo.algos.parameter_space import ParameterSpace\nfrom gemseo.datasets.dataset import Dataset\nfrom gemseo.disciplines.analytic import AnalyticDiscipline\nfrom numpy import array\nfrom numpy import nan\n\nfrom gemseo_calibration.scenario import CalibrationMeasure\nfrom gemseo_calibration.scenario import CalibrationScenario\n\nmodel = AnalyticDiscipline({\"y\": \"a*x\", \"z\": \"b*x\"}, name=\"model\")\n\nprior = ParameterSpace()\nprior.add_variable(\"a\", l_b=0.0, u_b=10.0, value=0.0)\nprior.add_variable(\"b\", l_b=0.0, u_b=10.0, value=0.0)\n\ndata = array([\n    [1, 1.0, 2.0, nan],\n    [2, 1.0, nan, 3.0],\n    [3, 2.0, 4.0, nan],\n    [4, 2.0, nan, 6.0],\n])\nreference_data = Dataset.from_array(\n    data,\n    variable_names=[\"index\", \"x\", \"y\", \"z\"],\n    variable_names_to_group_names={\n        \"index\": \"inputs\",\n        \"x\": \"inputs\",\n        \"y\": \"outputs\",\n        \"z\": \"outputs\",\n    },\n).to_dict_of_arrays(False)\n\ncontrol_outputs = [CalibrationMeasure(\"y\", \"MSE\"), CalibrationMeasure(\"z\", \"MSE\")]\ncalibration = CalibrationScenario(model, \"x\", control_outputs, prior)\ncalibration.execute({\n    \"algo\": \"NLOPT_COBYLA\",\n    \"reference_data\": reference_data,\n    \"max_iter\": 100,\n})\n</code></pre> <p>Total running time of the script: ( 0 minutes  1.504 seconds)</p> <p> Download Python source code: plot_calibration_with_missing_values.py</p> <p> Download Jupyter notebook: plot_calibration_with_missing_values.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/calibration/plot_calibration_with_noise/","title":"Plot calibration with noise","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/calibration/plot_calibration_with_noise/#calibration-scenario-with-noised-observations","title":"Calibration scenario with noised observations.","text":"<p>Let us consider a function \\(f(x)=ax^2+bx+c\\) from \\(\\mathbb{R}\\) to \\(\\mathbb{R}\\):</p> <pre><code>from __future__ import annotations\n\nfrom gemseo.algos.design_space import DesignSpace\nfrom gemseo.algos.parameter_space import ParameterSpace\nfrom gemseo.core.chain import MDOChain\nfrom gemseo.disciplines.analytic import AnalyticDiscipline\nfrom gemseo.disciplines.scenario_adapters.mdo_scenario_adapter import MDOScenarioAdapter\nfrom gemseo.scenarios.doe_scenario import DOEScenario\nfrom matplotlib import pyplot as plt\nfrom numpy import array\nfrom numpy import linspace\n\nfrom gemseo_calibration.scenario import CalibrationMeasure\nfrom gemseo_calibration.scenario import CalibrationScenario\n\nmodel = AnalyticDiscipline({\"y\": \"a*x**2+b*x+c\"}, name=\"model\")\n</code></pre> <p>This is a model of our reference data source, which a kind of oracle providing input-output data without the mathematical relationship behind it:</p> <pre><code>original_model = AnalyticDiscipline({\"y\": \"2*x**2-1.5*x+0.75\"}, name=\"model\")\n\nreference = MDOChain([original_model, AnalyticDiscipline({\"y\": \"y+u\"}, name=\"noise\")])\nreference.set_cache_policy(reference.CacheType.MEMORY_FULL)\n</code></pre> <p>This reference model contains a random additive term \\(u\\) normally distributed with mean \\(\\mu\\) and standard deviation \\(\\sigma\\). This means that the observations of \\(f:x\\mapsto 2*x^2-0.5*x\\) are noised.</p> <p>In this pedagogical example, the mathematical relationship is known and we can see that the parameters \\(a\\), \\(b\\) and \\(c\\) must be equal to 2, 0.5 and 0.75 respectively so that the model and the reference are identical.</p> <p>In the following, we will try to find these values from several information sources.</p> <p>Firstly, we have a prior information about the parameters, that is \\([a,b,c]\\in[-5,5]^2\\):</p> <pre><code>prior = ParameterSpace()\nprior.add_variable(\"a\", l_b=-5.0, u_b=5.0, value=0.0)\nprior.add_variable(\"b\", l_b=-5.0, u_b=5.0, value=0.0)\nprior.add_variable(\"c\", l_b=-5.0, u_b=5.0, value=0.0)\n</code></pre> <p>Secondly, we have reference output data over the input space \\([0.,3.]\\).</p> <pre><code>input_space = DesignSpace()\ninput_space.add_variable(\"x\", l_b=0.0, u_b=3.0, value=1.5)\n</code></pre> <p>These data are noisy; this noise can be modeled by a centered Gaussian random variable with standard deviation equal to 0.5.</p> <pre><code>noise_space = ParameterSpace()\nnoise_space.add_random_variable(\"u\", \"OTNormalDistribution\", mu=0.0, sigma=0.5)\n</code></pre> <p>The observations can be generated with two nested design of experiments: an inner one sampling the reference model \\(f\\), an outer one repeating this sampling for different values of the noise. A classical way of doing this with |g| is to use a MDOScenarioAdapter which is an MDODiscipline executing a DOEScenario for a given value of \\(u\\). For example, let us imagine a DOEScenario evaluating the reference data source at 5 equispaced points \\(x_1,\\ldots,x_5\\).</p> <pre><code>sub_scenario = DOEScenario([reference], \"DisciplinaryOpt\", \"y\", input_space)\nsub_scenario.default_inputs = {\"algo\": \"fullfact\", \"n_samples\": 5}\n\nadapter = MDOScenarioAdapter(sub_scenario, [\"u\"], [\"y\"])\n</code></pre> <p>Then, this MDOScenarioAdapter is embedded in a DOEScenario in charge to sample it over the uncertain space.</p> <pre><code>scenario = DOEScenario([adapter], \"DisciplinaryOpt\", \"y\", noise_space)\nscenario.execute({\"algo\": \"OT_LHSC\", \"n_samples\": 5})\nreference_data = reference.cache.to_dataset().to_dict_of_arrays(False)\n</code></pre> <p>From these information sources, we can build and execute a CalibrationScenario to find the value of the parameters \\(a\\), \\(b\\) and \\(c\\) which minimizes a CalibrationMeasure related to the output \\(y\\):</p> <pre><code>calibration = CalibrationScenario(model, \"x\", CalibrationMeasure(\"y\", \"MSE\"), prior)\ncalibration.execute({\n    \"algo\": \"NLOPT_COBYLA\",\n    \"reference_data\": reference_data,\n    \"max_iter\": 100,\n})\n</code></pre> <p>Out:</p> <pre><code>{'reference_data': {'u': array([[ 0.64077578],\n       [ 0.64077578],\n       [ 0.64077578],\n       [ 0.64077578],\n       [ 0.64077578],\n       [-0.26220026],\n       [-0.26220026],\n       [-0.26220026],\n       [-0.26220026],\n       [-0.26220026],\n       [-0.64077578],\n       [-0.64077578],\n       [-0.64077578],\n       [-0.64077578],\n       [-0.64077578],\n       [ 0.        ],\n       [ 0.        ],\n       [ 0.        ],\n       [ 0.        ],\n       [ 0.        ],\n       [ 0.26220026],\n       [ 0.26220026],\n       [ 0.26220026],\n       [ 0.26220026],\n       [ 0.26220026]]), 'x': array([[0.  ],\n       [0.75],\n       [1.5 ],\n       [2.25],\n       [3.  ],\n       [0.  ],\n       [0.75],\n       [1.5 ],\n       [2.25],\n       [3.  ],\n       [0.  ],\n       [0.75],\n       [1.5 ],\n       [2.25],\n       [3.  ],\n       [0.  ],\n       [0.75],\n       [1.5 ],\n       [2.25],\n       [3.  ],\n       [0.  ],\n       [0.75],\n       [1.5 ],\n       [2.25],\n       [3.  ]]), 'y': array([[ 1.39077578],\n       [ 1.39077578],\n       [ 3.64077578],\n       [ 8.14077578],\n       [14.89077578],\n       [ 0.48779974],\n       [ 0.48779974],\n       [ 2.73779974],\n       [ 7.23779974],\n       [13.98779974],\n       [ 0.10922422],\n       [ 0.10922422],\n       [ 2.35922422],\n       [ 6.85922422],\n       [13.60922422],\n       [ 0.75      ],\n       [ 0.75      ],\n       [ 3.        ],\n       [ 7.5       ],\n       [14.25      ],\n       [ 1.01220026],\n       [ 1.01220026],\n       [ 3.26220026],\n       [ 7.76220026],\n       [14.51220026]])}, 'max_iter': 100, 'algo': 'NLOPT_COBYLA'}\n</code></pre> <p>Lastly, we get the calibrated parameters:</p> <p>plot an optimization history view:</p> <pre><code>calibration.post_process(\"OptHistoryView\", save=False, show=True)\n</code></pre> <p>Out:</p> <pre><code>&lt;gemseo.post.opt_history_view.OptHistoryView object at 0x78620d31d550&gt;\n</code></pre> <p>as well as the model data versus the reference ones:</p> <pre><code>expression = \"a*x**2+b*x+c\"\nfor parameter_name, parameter_value in calibration.posterior_parameters.items():\n    expression = expression.replace(parameter_name, str(parameter_value[0]))\ncalibrated = AnalyticDiscipline({\"y\": expression}, name=\"calibrated\")\n\nx_values = linspace(0.0, 3.0, 100)\ny_values = [original_model.execute({\"x\": array([x_i])})[\"y\"][0] for x_i in x_values]\npost_y_values = [calibrated.execute({\"x\": array([x_i])})[\"y\"][0] for x_i in x_values]\nplt.plot(x_values, y_values, color=\"blue\", label=\"Unknown model\")\nplt.plot(x_values, post_y_values, color=\"red\", label=\"Calibrated model\")\n\nx_points = []\ny_points = []\nfor data in reference.cache:\n    x_points.append(data.inputs[\"x\"][0])\n    y_points.append(data.outputs[\"y\"][0])\n\nplt.plot(\n    x_points,\n    y_points,\n    color=\"blue\",\n    linestyle=\"\",\n    marker=\"x\",\n    label=\"Reference data\",\n)\nplt.legend()\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  3.185 seconds)</p> <p> Download Python source code: plot_calibration_with_noise.py</p> <p> Download Jupyter notebook: plot_calibration_with_noise.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>gemseo_calibration<ul> <li>calibrator</li> <li>measure</li> <li>measures<ul> <li>factory</li> <li>iae</li> <li>integrated_measure</li> <li>ise</li> <li>mae</li> <li>mean_measure</li> <li>mse</li> </ul> </li> <li>post<ul> <li>data_versus_model<ul> <li>post</li> </ul> </li> <li>factory</li> <li>multiple_scatter</li> </ul> </li> <li>post_processor</li> <li>scenario</li> </ul> </li> </ul>"},{"location":"reference/gemseo_calibration/","title":"API documentation","text":""},{"location":"reference/gemseo_calibration/#gemseo_calibration","title":"gemseo_calibration","text":"<p>A package to calibrate a multidisciplinary system from reference data.</p>"},{"location":"reference/gemseo_calibration/calibrator/","title":"Calibrator","text":""},{"location":"reference/gemseo_calibration/calibrator/#gemseo_calibration.calibrator","title":"calibrator","text":"<p>A discipline evaluating the quality of another one with respect to reference data.</p>"},{"location":"reference/gemseo_calibration/calibrator/#gemseo_calibration.calibrator-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/calibrator/#gemseo_calibration.calibrator-classes","title":"Classes","text":""},{"location":"reference/gemseo_calibration/calibrator/#gemseo_calibration.calibrator.CalibrationMeasure","title":"CalibrationMeasure","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A calibration measure.</p>"},{"location":"reference/gemseo_calibration/calibrator/#gemseo_calibration.calibrator.CalibrationMeasure-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/calibrator/#gemseo_calibration.calibrator.CalibrationMeasure.measure","title":"measure  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>measure: str = 'MSE'\n</code></pre> <p>The name of the measure to compare the observed and simulated outputs.</p>"},{"location":"reference/gemseo_calibration/calibrator/#gemseo_calibration.calibrator.CalibrationMeasure.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mesh: str | None = None\n</code></pre> <p>The name of the irregular mesh associated with the output if any.</p> <p>To be used when the output is a 1D function discretized over an irregular mesh.</p>"},{"location":"reference/gemseo_calibration/calibrator/#gemseo_calibration.calibrator.CalibrationMeasure.output","title":"output  <code>instance-attribute</code>","text":"<pre><code>output: str\n</code></pre> <p>The name of the output.</p>"},{"location":"reference/gemseo_calibration/calibrator/#gemseo_calibration.calibrator.CalibrationMeasure.weight","title":"weight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weight: float | None = None\n</code></pre> <p>The weight of this measure when the measure is an element of a collection.</p> <p>The weight must be between 0 and 1. The sum of the weights of the elements in the collection must be 1.</p>"},{"location":"reference/gemseo_calibration/calibrator/#gemseo_calibration.calibrator.Calibrator","title":"Calibrator","text":"<pre><code>Calibrator(\n    disciplines: MDODiscipline | list[MDODiscipline],\n    input_names: str | Iterable[str],\n    control_outputs: (\n        CalibrationMeasure | Sequence[CalibrationMeasure]\n    ),\n    parameter_names: str | Iterable[str],\n    formulation: str = \"MDF\",\n    **formulation_options: Any\n)\n</code></pre> <p>               Bases: <code>MDOScenarioAdapter</code></p> <p>A discipline with parameters calibrated from reference input-output data.</p> <p>When it is executed from parameters values, it computes the calibration measure with respect to the reference data, provided through the set_reference_data method.</p> <p>Initialize self.  See help(type(self)) for accurate signature.</p> <p>Parameters:</p> <ul> <li> <code>disciplines</code>               (<code>MDODiscipline | list[MDODiscipline]</code>)           \u2013            <p>The disciplines whose parameters must be calibrated from the reference data.</p> </li> <li> <code>input_names</code>               (<code>str | Iterable[str]</code>)           \u2013            <p>The names of the inputs to be considered for the calibration.</p> </li> <li> <code>control_outputs</code>               (<code>CalibrationMeasure | Sequence[CalibrationMeasure]</code>)           \u2013            <p>The names of the outputs used to calibrate the disciplines with the name of the calibration measure and the corresponding weight comprised between 0 and 1 (the weights must sum to 1). When the output is a 1D function discretized over an irregular mesh, the name of the mesh can be provided. E.g. <code>CalibrationMeasure(output=\"z\", measure=\"MSE\")</code> <code>CalibrationMeasure(output=\"z\", measure=\"MSE\", weight=0.3)</code> or <code>CalibrationMeasure(output=\"z\", measure=\"MSE\", mesh=\"z_mesh\")</code> Lastly, <code>CalibrationMeasure</code> can be imported from gemseo-calibration.calibrator.</p> </li> <li> <code>parameter_names</code>               (<code>str | Iterable[str]</code>)           \u2013            <p>The names of the parameters to be calibrated.</p> </li> <li> <code>formulation</code>               (<code>str</code>, default:                   <code>'MDF'</code> )           \u2013            <p>The name of a formulation to manage the multidisciplinary coupling.</p> </li> <li> <code>**formulation_options</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>The options of the formulation.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If both <code>reset_x0_before_opt</code> and <code>set_x0_before_opt</code> are True.</p> </li> </ul> Source code in <code>src/gemseo_calibration/calibrator.py</code> <pre><code>def __init__(\n    self,\n    disciplines: MDODiscipline | list[MDODiscipline],\n    input_names: str | Iterable[str],\n    control_outputs: CalibrationMeasure | Sequence[CalibrationMeasure],\n    parameter_names: str | Iterable[str],\n    formulation: str = \"MDF\",\n    **formulation_options: Any,\n) -&gt; None:\n    \"\"\"\n    Args:\n        disciplines: The disciplines\n            whose parameters must be calibrated from the reference data.\n        input_names: The names of the inputs to be considered for the calibration.\n        control_outputs: The names of the outputs used to calibrate the disciplines\n            with the name of the calibration measure and the corresponding weight\n            comprised between 0 and 1 (the weights must sum to 1).\n            When the output is a 1D function discretized over an irregular mesh,\n            the name of the mesh can be provided.\n            E.g. `CalibrationMeasure(output=\"z\", measure=\"MSE\")`\n            `CalibrationMeasure(output=\"z\", measure=\"MSE\", weight=0.3)`\n            or `CalibrationMeasure(output=\"z\", measure=\"MSE\", mesh=\"z_mesh\")`\n            Lastly, `CalibrationMeasure` can be imported\n            from [gemseo-calibration.calibrator][gemseo-calibration.calibrator].\n        parameter_names: The names of the parameters to be calibrated.\n        formulation: The name of a formulation\n            to manage the multidisciplinary coupling.\n        **formulation_options: The options of the formulation.\n    \"\"\"  # noqa: D205,D212,D415\n    self.__measure_factory = CalibrationMeasureFactory()\n    input_names = self.__to_iterable(input_names, str)\n    control_outputs = self.__to_iterable(control_outputs, CalibrationMeasure)\n    parameter_names = self.__to_iterable(parameter_names, str)\n    disciplines = self.__to_iterable(disciplines, MDODiscipline)\n    control_output = control_outputs[0]\n    objective_name = control_output.output\n    mesh_name = control_output.mesh\n    input_space = DesignSpace()\n    for name in input_names:\n        input_space.add_variable(name)\n\n    doe_scenario = DOEScenario(\n        disciplines,\n        formulation,\n        objective_name,\n        input_space,\n        **formulation_options,\n    )\n    if mesh_name:\n        doe_scenario.add_observable(mesh_name)\n\n    self.__add_observables(control_outputs, doe_scenario)\n\n    doe_scenario.default_inputs = {\n        doe_scenario.ALGO: CustomDOE.__name__,\n        self.__ALGO_OPTIONS: {\"samples\": None},\n    }\n\n    self.__names_to_measures = {}\n    self.__measures = []\n    self.objective_name, output_names = self._add_measure(control_outputs)\n    super().__init__(doe_scenario, parameter_names, output_names, name=\"Calibrator\")\n    self.__update_output_grammar()\n    self.__reference_data = {}\n</code></pre>"},{"location":"reference/gemseo_calibration/calibrator/#gemseo_calibration.calibrator.Calibrator-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/calibrator/#gemseo_calibration.calibrator.Calibrator.maximize_objective_measure","title":"maximize_objective_measure  <code>property</code>","text":"<pre><code>maximize_objective_measure: bool\n</code></pre> <p>Whether to maximize the calibration measure related to the objectives.</p>"},{"location":"reference/gemseo_calibration/calibrator/#gemseo_calibration.calibrator.Calibrator.reference_data","title":"reference_data  <code>property</code>","text":"<pre><code>reference_data: DataType\n</code></pre> <p>The reference data used for the calibration.</p>"},{"location":"reference/gemseo_calibration/calibrator/#gemseo_calibration.calibrator.Calibrator-functions","title":"Functions","text":""},{"location":"reference/gemseo_calibration/calibrator/#gemseo_calibration.calibrator.Calibrator.add_measure","title":"add_measure","text":"<pre><code>add_measure(\n    control_outputs: (\n        CalibrationMeasure | Iterable[CalibrationMeasure]\n    ),\n) -&gt; tuple[str, list[str]]\n</code></pre> <p>Create a new calibration measure and add it to the outputs of the adapter.</p> <p>Parameters:</p> <ul> <li> <code>control_outputs</code>               (<code>CalibrationMeasure | Iterable[CalibrationMeasure]</code>)           \u2013            <p>The names of the outputs used to calibrate the disciplines with the name of the calibration measure and the corresponding weight comprised between 0 and 1 (the weights must sum to 1). When the output is a 1D function discretized over an irregular mesh, the name of the mesh can be provided. E.g. <code>CalibrationMeasure(output=\"z\", measure=\"MSE\")</code> <code>CalibrationMeasure(output=\"z\", measure=\"MSE\", weight=0.3)</code> or <code>CalibrationMeasure(output=\"z\", measure=\"MSE\", mesh=\"z_mesh\")</code> Lastly, <code>CalibrationMeasure</code> can be imported from :mod:<code>gemseo-calibration.scenario</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[str, list[str]]</code>           \u2013            <p>The name of the calibration measure applied to the outputs.</p> </li> </ul> Source code in <code>src/gemseo_calibration/calibrator.py</code> <pre><code>def add_measure(\n    self,\n    control_outputs: CalibrationMeasure | Iterable[CalibrationMeasure],\n) -&gt; tuple[str, list[str]]:\n    \"\"\"Create a new calibration measure and add it to the outputs of the adapter.\n\n    Args:\n        control_outputs: The names of the outputs used to calibrate the disciplines\n            with the name of the calibration measure and the corresponding weight\n            comprised between 0 and 1 (the weights must sum to 1).\n            When the output is a 1D function discretized over an irregular mesh,\n            the name of the mesh can be provided.\n            E.g. ``CalibrationMeasure(output=\"z\", measure=\"MSE\")``\n            ``CalibrationMeasure(output=\"z\", measure=\"MSE\", weight=0.3)``\n            or ``CalibrationMeasure(output=\"z\", measure=\"MSE\", mesh=\"z_mesh\")``\n            Lastly, ``CalibrationMeasure`` can be imported\n            from :mod:`gemseo-calibration.scenario`.\n\n    Returns:\n        The name of the calibration measure applied to the outputs.\n    \"\"\"\n    control_outputs = self.__to_control_outputs(control_outputs)\n    self.__add_observables(control_outputs, self.scenario)\n    return_values = self._add_measure(control_outputs)\n    self.__update_output_grammar()\n    return return_values\n</code></pre>"},{"location":"reference/gemseo_calibration/calibrator/#gemseo_calibration.calibrator.Calibrator.set_reference_data","title":"set_reference_data","text":"<pre><code>set_reference_data(reference_data: DataType) -&gt; None\n</code></pre> <p>Pass the reference data to the scenario and to the measures.</p> <p>Parameters:</p> <ul> <li> <code>reference_data</code>               (<code>DataType</code>)           \u2013            <p>The reference data with which to compare the discipline.</p> </li> </ul> Source code in <code>src/gemseo_calibration/calibrator.py</code> <pre><code>def set_reference_data(self, reference_data: DataType) -&gt; None:\n    \"\"\"Pass the reference data to the scenario and to the measures.\n\n    Args:\n        reference_data: The reference data with which to compare the discipline.\n    \"\"\"\n    self.__reference_data = reference_data\n    design_space = self.scenario.design_space\n    for name in tuple(design_space):\n        del design_space[name]\n        design_space.add_variable(name, size=reference_data[name].shape[1])\n\n    self.scenario.default_inputs[self.__ALGO_OPTIONS][\"samples\"] = hstack([\n        reference_data[name] for name in self.scenario.get_optim_variable_names()\n    ])\n    for measure in self.__measures:\n        measure.set_reference_data(self.__reference_data)\n</code></pre>"},{"location":"reference/gemseo_calibration/measure/","title":"Measure","text":""},{"location":"reference/gemseo_calibration/measure/#gemseo_calibration.measure","title":"measure","text":"<p>A module to measure the consistency or the inconsistency between two data sets.</p>"},{"location":"reference/gemseo_calibration/measure/#gemseo_calibration.measure-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/measure/#gemseo_calibration.measure.DataType","title":"DataType  <code>module-attribute</code>","text":"<pre><code>DataType = dict[str, RealArray]\n</code></pre> <p>The type of data.</p> <p>The data are set as <code>{variable_name: variable_values}</code> where <code>variable_values</code> is a 2D NumPy array whose rows are the samples and columns are the components of the variable.</p>"},{"location":"reference/gemseo_calibration/measure/#gemseo_calibration.measure-classes","title":"Classes","text":""},{"location":"reference/gemseo_calibration/measure/#gemseo_calibration.measure.CalibrationMeasure","title":"CalibrationMeasure","text":"<pre><code>CalibrationMeasure(\n    output_name: str,\n    name: str = \"\",\n    f_type: FunctionType = MDOFunction.FunctionType.NONE,\n)\n</code></pre> <p>               Bases: <code>MDOFunction</code></p> <p>A measure of the consistency (or inconsistency) between two data sets.</p> <p>Parameters:</p> <ul> <li> <code>output_name</code>               (<code>str</code>)           \u2013            <p>The name of the output to be taken into account by the measure.</p> </li> </ul> Source code in <code>src/gemseo_calibration/measure.py</code> <pre><code>def __init__(\n    self,\n    output_name: str,\n    name: str = \"\",\n    f_type: MDOFunction.FunctionType = MDOFunction.FunctionType.NONE,\n) -&gt; None:\n    \"\"\"\n    Args:\n        output_name: The name of the output to be taken into account by the measure.\n    \"\"\"  # noqa: D205,D212,D415\n    self.output_name = output_name\n    super().__init__(\n        self._evaluate_measure, name or self._compute_name(), f_type=f_type\n    )\n    self._lower_bound = -inf\n    self._upper_bound = inf\n    self._reference_data = []\n</code></pre>"},{"location":"reference/gemseo_calibration/measure/#gemseo_calibration.measure.CalibrationMeasure-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/measure/#gemseo_calibration.measure.CalibrationMeasure.full_output_name","title":"full_output_name  <code>property</code>","text":"<pre><code>full_output_name: str\n</code></pre> <p>The full name of the output.</p>"},{"location":"reference/gemseo_calibration/measure/#gemseo_calibration.measure.CalibrationMeasure.maximize","title":"maximize  <code>class-attribute</code>","text":"<pre><code>maximize: bool = False\n</code></pre> <p>Whether to maximize the calibration measure.</p>"},{"location":"reference/gemseo_calibration/measure/#gemseo_calibration.measure.CalibrationMeasure.output_name","title":"output_name  <code>instance-attribute</code>","text":"<pre><code>output_name: str = output_name\n</code></pre> <p>The name of the output used by the measure for calibration.</p>"},{"location":"reference/gemseo_calibration/measure/#gemseo_calibration.measure.CalibrationMeasure-functions","title":"Functions","text":""},{"location":"reference/gemseo_calibration/measure/#gemseo_calibration.measure.CalibrationMeasure.set_reference_data","title":"set_reference_data","text":"<pre><code>set_reference_data(reference_dataset: DataType) -&gt; None\n</code></pre> <p>Define the reference input-output data set.</p> <p>Parameters:</p> <ul> <li> <code>reference_dataset</code>               (<code>DataType</code>)           \u2013            <p>The reference input-output data set.</p> </li> </ul> Source code in <code>src/gemseo_calibration/measure.py</code> <pre><code>def set_reference_data(self, reference_dataset: DataType) -&gt; None:\n    \"\"\"Define the reference input-output data set.\n\n    Args:\n        reference_dataset: The reference input-output data set.\n    \"\"\"\n    self._reference_data = reference_dataset[self.output_name]\n    self._lower_bound = nanmin(self._reference_data)\n    self._upper_bound = nanmax(self._reference_data)\n</code></pre>"},{"location":"reference/gemseo_calibration/post_processor/","title":"Post processor","text":""},{"location":"reference/gemseo_calibration/post_processor/#gemseo_calibration.post_processor","title":"post_processor","text":"<p>Base class for all calibration post-processing methods.</p>"},{"location":"reference/gemseo_calibration/post_processor/#gemseo_calibration.post_processor-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/post_processor/#gemseo_calibration.post_processor-classes","title":"Classes","text":""},{"location":"reference/gemseo_calibration/post_processor/#gemseo_calibration.post_processor.CalibrationPostProcessor","title":"CalibrationPostProcessor","text":"<pre><code>CalibrationPostProcessor(\n    opt_problem: OptimizationProblem,\n    reference_data: DataType,\n    prior_model_data: DataType,\n    posterior_model_data: DataType,\n)\n</code></pre> <p>               Bases: <code>OptPostProcessor</code></p> <p>Abstract class for optimization post-processing methods.</p> <p>Parameters:</p> <ul> <li> <code>opt_problem</code>               (<code>OptimizationProblem</code>)           \u2013            <p>The optimization problem to run.</p> </li> <li> <code>reference_data</code>               (<code>DataType</code>)           \u2013            <p>The reference data.</p> </li> <li> <code>prior_model_data</code>               (<code>DataType</code>)           \u2013            <p>The model data before the calibration.</p> </li> <li> <code>posterior_model_data</code>               (<code>DataType</code>)           \u2013            <p>The model data after the calibration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the JSON grammar file for the options of the post-processor does not exist.</p> </li> </ul> Source code in <code>src/gemseo_calibration/post_processor.py</code> <pre><code>def __init__(\n    self,\n    opt_problem: OptimizationProblem,\n    reference_data: DataType,\n    prior_model_data: DataType,\n    posterior_model_data: DataType,\n) -&gt; None:\n    \"\"\"\n    Args:\n        opt_problem: The optimization problem to run.\n        reference_data: The reference data.\n        prior_model_data: The model data before the calibration.\n        posterior_model_data: The model data after the calibration.\n    \"\"\"  # noqa: D205, D212, D415\n    super().__init__(opt_problem)\n    self._reference_data = reference_data\n    self._prior_model_data = prior_model_data\n    self._posterior_model_data = posterior_model_data\n</code></pre>"},{"location":"reference/gemseo_calibration/scenario/","title":"Scenario","text":""},{"location":"reference/gemseo_calibration/scenario/#gemseo_calibration.scenario","title":"scenario","text":"<p>A module to calibrate a multidisciplinary system from data.</p>"},{"location":"reference/gemseo_calibration/scenario/#gemseo_calibration.scenario-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/scenario/#gemseo_calibration.scenario-classes","title":"Classes","text":""},{"location":"reference/gemseo_calibration/scenario/#gemseo_calibration.scenario.CalibrationScenario","title":"CalibrationScenario","text":"<pre><code>CalibrationScenario(\n    disciplines: MDODiscipline | list[MDODiscipline],\n    input_names: str | Iterable[str],\n    control_outputs: (\n        CalibrationMeasure | Sequence[CalibrationMeasure]\n    ),\n    calibration_space: DesignSpace,\n    formulation: str = \"MDF\",\n    name: str = \"\",\n    **formulation_options: Any\n)\n</code></pre> <p>               Bases: <code>MDOScenario</code></p> <p>A scenario to calibrate a multidisciplinary system from reference data.</p> <p>Set from parameters, this multidisciplinary system computes output data from input data.</p> <p>The reference input-output data are used to calibrate the parameters so that the model output data are close to the reference output data for some outputs of interest. This distance is evaluated with a CalibrationMeasure to compare the discipline outputs with the reference data.</p> Warning <p>Just like inputs, the parameters should be defined in the input grammars of the disciplines.</p> <p>The parameters are calibrated with the method execute from an optimizer and a reference IODataset.</p> <p>Initialize self.  See help(type(self)) for accurate signature.</p> <p>Parameters:</p> <ul> <li> <code>disciplines</code>               (<code>MDODiscipline | list[MDODiscipline]</code>)           \u2013            <p>The disciplines whose parameters must be calibrated from the reference data.</p> </li> <li> <code>input_names</code>               (<code>str | Iterable[str]</code>)           \u2013            <p>The names of the inputs to be considered for the calibration.</p> </li> <li> <code>control_outputs</code>               (<code>CalibrationMeasure | Sequence[CalibrationMeasure]</code>)           \u2013            <p>The names of the outputs used to calibrate the disciplines with the name of the calibration measure and the corresponding weight comprised between 0 and 1 (the weights must sum to 1). When the output is a 1D function discretized over an irregular mesh, the name of the mesh can be provided. E.g. <code>CalibrationMeasure(output=\"z\", measure=\"MSE\")</code> <code>CalibrationMeasure(output=\"z\", measure=\"MSE\", weight=0.3)</code> or <code>CalibrationMeasure(output=\"z\", measure=\"MSE\", mesh=\"z_mesh\")</code> Lastly, <code>CalibrationMeasure</code> can be imported from :mod:<code>gemseo-calibration.scenario</code>.</p> </li> <li> <code>calibration_space</code>               (<code>DesignSpace</code>)           \u2013            <p>The space of the parameters to be calibrated, whose current values are consider as a prior for calibration.</p> </li> <li> <code>formulation</code>               (<code>str</code>, default:                   <code>'MDF'</code> )           \u2013            <p>The name of a formulation to manage the multidisciplinary coupling.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>A name for this calibration scenario. If empty, use the name of the class.</p> </li> <li> <code>**formulation_options</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>The options of the formulation.</p> </li> </ul> Source code in <code>src/gemseo_calibration/scenario.py</code> <pre><code>def __init__(\n    self,\n    disciplines: MDODiscipline | list[MDODiscipline],\n    input_names: str | Iterable[str],\n    control_outputs: CalibrationMeasure | Sequence[CalibrationMeasure],\n    calibration_space: DesignSpace,\n    formulation: str = \"MDF\",\n    name: str = \"\",\n    **formulation_options: Any,\n) -&gt; None:\n    \"\"\"\n    Args:\n        disciplines: The disciplines\n            whose parameters must be calibrated from the reference data.\n        input_names: The names of the inputs to be considered for the calibration.\n        control_outputs: The names of the outputs used to calibrate the disciplines\n            with the name of the calibration measure and the corresponding weight\n            comprised between 0 and 1 (the weights must sum to 1).\n            When the output is a 1D function discretized over an irregular mesh,\n            the name of the mesh can be provided.\n            E.g. `CalibrationMeasure(output=\"z\", measure=\"MSE\")`\n            `CalibrationMeasure(output=\"z\", measure=\"MSE\", weight=0.3)`\n            or `CalibrationMeasure(output=\"z\", measure=\"MSE\", mesh=\"z_mesh\")`\n            Lastly, `CalibrationMeasure` can be imported\n            from :mod:`gemseo-calibration.scenario`.\n        calibration_space: The space of the parameters to be calibrated,\n            whose current values are consider as a prior for calibration.\n        formulation: The name of a formulation\n            to manage the multidisciplinary coupling.\n        name: A name for this calibration scenario.\n            If empty, use the name of the class.\n        **formulation_options: The options of the formulation.\n    \"\"\"  # noqa: D205,D212,D415\n    self.__prior_parameters = calibration_space.get_current_value(as_dict=True)\n    self.__posterior_parameters = {}\n    self.prior_model_data = {}\n    self.posterior_model_data = {}\n    calibrator = Calibrator(\n        disciplines,\n        input_names,\n        control_outputs,\n        calibration_space.variable_names,\n        formulation=formulation,\n        **formulation_options,\n    )\n    super().__init__(\n        [calibrator],\n        \"DisciplinaryOpt\",\n        calibrator.objective_name,\n        calibration_space,\n        name=name or self.__class__.__name__,\n        maximize_objective=calibrator.maximize_objective_measure,\n    )\n    self.__calibration_post_factory = CalibrationPostFactory()\n</code></pre>"},{"location":"reference/gemseo_calibration/scenario/#gemseo_calibration.scenario.CalibrationScenario-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/scenario/#gemseo_calibration.scenario.CalibrationScenario.calibrator","title":"calibrator  <code>property</code>","text":"<pre><code>calibrator: Calibrator\n</code></pre> <p>The discipline computing calibration measures from the parameter values.</p>"},{"location":"reference/gemseo_calibration/scenario/#gemseo_calibration.scenario.CalibrationScenario.posterior_model_data","title":"posterior_model_data  <code>instance-attribute</code>","text":"<pre><code>posterior_model_data: dict[str, RealArray] = {}\n</code></pre> <p>The model data after the calibration.</p>"},{"location":"reference/gemseo_calibration/scenario/#gemseo_calibration.scenario.CalibrationScenario.posterior_parameters","title":"posterior_parameters  <code>property</code>","text":"<pre><code>posterior_parameters: DataType\n</code></pre> <p>The values of the parameters after the calibration stage.</p>"},{"location":"reference/gemseo_calibration/scenario/#gemseo_calibration.scenario.CalibrationScenario.prior_model_data","title":"prior_model_data  <code>instance-attribute</code>","text":"<pre><code>prior_model_data: dict[str, RealArray] = {}\n</code></pre> <p>The model data before the calibration.</p>"},{"location":"reference/gemseo_calibration/scenario/#gemseo_calibration.scenario.CalibrationScenario.prior_parameters","title":"prior_parameters  <code>property</code>","text":"<pre><code>prior_parameters: DataType\n</code></pre> <p>The values of the parameters before the calibration stage.</p>"},{"location":"reference/gemseo_calibration/scenario/#gemseo_calibration.scenario.CalibrationScenario-functions","title":"Functions","text":""},{"location":"reference/gemseo_calibration/scenario/#gemseo_calibration.scenario.CalibrationScenario.add_constraint","title":"add_constraint","text":"<pre><code>add_constraint(\n    control_outputs: (\n        CalibrationMeasure | Iterable[CalibrationMeasure]\n    ),\n    constraint_type: ConstraintType = MDOFunction.ConstraintType.EQ,\n    constraint_name: str = \"\",\n    value: float = 0.0,\n    positive: bool = False,\n) -&gt; None\n</code></pre> <p>Define a constraint from a calibration measure related to discipline outputs.</p> <p>Parameters:</p> <ul> <li> <code>control_outputs</code>               (<code>CalibrationMeasure | Iterable[CalibrationMeasure]</code>)           \u2013            <p>The names of the outputs used to calibrate the disciplines with the name of the calibration measure and the corresponding weight comprised between 0 and 1 (the weights must sum to 1). When the output is a 1D function discretized over an irregular mesh, the name of the mesh can be provided. E.g. <code>CalibrationMeasure(output=\"z\", measure=\"MSE\")</code> <code>CalibrationMeasure(output=\"z\", measure=\"MSE\", weight=0.3)</code> or <code>CalibrationMeasure(output=\"z\", measure=\"MSE\", mesh=\"z_mesh\")</code> Lastly, <code>CalibrationMeasure</code> can be imported from :mod:<code>gemseo-calibration.scenario</code>.</p> </li> <li> <code>constraint_type</code>               (<code>ConstraintType</code>, default:                   <code>EQ</code> )           \u2013            <p>The type of constraint, <code>\"eq\"</code> for equality constraint and <code>\"ineq\"</code> for inequality constraint.</p> </li> <li> <code>constraint_name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The name of the constraint to be stored. If empty, the name of the constraint is generated from the output name.</p> </li> <li> <code>value</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The value for which the constraint is active.</p> </li> <li> <code>positive</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to consider the inequality constraint as positive.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the constraint type is neither 'eq' nor 'ineq'.</p> </li> </ul> Source code in <code>src/gemseo_calibration/scenario.py</code> <pre><code>def add_constraint(\n    self,\n    control_outputs: CalibrationMeasure | Iterable[CalibrationMeasure],\n    constraint_type: MDOFunction.ConstraintType = MDOFunction.ConstraintType.EQ,\n    constraint_name: str = \"\",\n    value: float = 0.0,\n    positive: bool = False,\n) -&gt; None:\n    \"\"\"Define a constraint from a calibration measure related to discipline outputs.\n\n    Args:\n        control_outputs: The names of the outputs used to calibrate the disciplines\n            with the name of the calibration measure and the corresponding weight\n            comprised between 0 and 1 (the weights must sum to 1).\n            When the output is a 1D function discretized over an irregular mesh,\n            the name of the mesh can be provided.\n            E.g. `CalibrationMeasure(output=\"z\", measure=\"MSE\")`\n            `CalibrationMeasure(output=\"z\", measure=\"MSE\", weight=0.3)`\n            or `CalibrationMeasure(output=\"z\", measure=\"MSE\", mesh=\"z_mesh\")`\n            Lastly, `CalibrationMeasure` can be imported\n            from :mod:`gemseo-calibration.scenario`.\n        constraint_type: The type of constraint,\n            `\"eq\"` for equality constraint and\n            `\"ineq\"` for inequality constraint.\n        constraint_name: The name of the constraint to be stored.\n            If empty,\n            the name of the constraint is generated from the output name.\n        value: The value for which the constraint is active.\n        positive: Whether to consider the inequality constraint as positive.\n    \"\"\"\n    super().add_constraint(\n        self.calibrator.add_measure(control_outputs)[0],\n        constraint_type,\n        constraint_name,\n        value,\n        positive,\n    )\n</code></pre>"},{"location":"reference/gemseo_calibration/scenario/#gemseo_calibration.scenario.CalibrationScenario.post_process","title":"post_process","text":"<pre><code>post_process(\n    post_name: str, **options: Any\n) -&gt; OptPostProcessor\n</code></pre> <p>Post-process the optimization history.</p> <p>Parameters:</p> <ul> <li> <code>post_name</code>               (<code>str</code>)           \u2013            <p>The name of the post-processor, i.e. the name of a class inheriting from :class:<code>.OptPostProcessor</code>.</p> </li> <li> <code>**options</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>The options for the post-processor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptPostProcessor</code>           \u2013            <p>The post-processing instance related to the optimization scenario.</p> </li> </ul> Source code in <code>src/gemseo_calibration/scenario.py</code> <pre><code>def post_process(self, post_name: str, **options: Any) -&gt; OptPostProcessor:  # noqa: D102\n    if post_name in self.__calibration_post_factory.class_names:\n        return self.__calibration_post_factory.execute(\n            self.formulation.optimization_problem,\n            self.calibrator.reference_data,\n            self.prior_model_data,\n            self.posterior_model_data,\n            post_name,\n            **options,\n        )\n\n    return super().post_process(post_name, **options)\n</code></pre>"},{"location":"reference/gemseo_calibration/measures/","title":"Measures","text":""},{"location":"reference/gemseo_calibration/measures/#gemseo_calibration.measures","title":"measures","text":"<p>Measures of the consistency (or inconsistency) between two data sets.</p>"},{"location":"reference/gemseo_calibration/measures/factory/","title":"Factory","text":""},{"location":"reference/gemseo_calibration/measures/factory/#gemseo_calibration.measures.factory","title":"factory","text":"<p>A factory of calibration measures.</p>"},{"location":"reference/gemseo_calibration/measures/factory/#gemseo_calibration.measures.factory-classes","title":"Classes","text":""},{"location":"reference/gemseo_calibration/measures/factory/#gemseo_calibration.measures.factory.CalibrationMeasureFactory","title":"CalibrationMeasureFactory","text":"<p>               Bases: <code>BaseFactory</code></p> <p>A factory of calibration measures.</p>"},{"location":"reference/gemseo_calibration/measures/factory/#gemseo_calibration.measures.factory.CalibrationMeasureFactory-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/measures/factory/#gemseo_calibration.measures.factory.CalibrationMeasureFactory.measures","title":"measures  <code>property</code>","text":"<pre><code>measures: list[str]\n</code></pre> <p>The names of the available calibration measures.</p>"},{"location":"reference/gemseo_calibration/measures/factory/#gemseo_calibration.measures.factory.CalibrationMeasureFactory-functions","title":"Functions","text":""},{"location":"reference/gemseo_calibration/measures/factory/#gemseo_calibration.measures.factory.CalibrationMeasureFactory.is_integrated_measure","title":"is_integrated_measure","text":"<pre><code>is_integrated_measure(name: str) -&gt; bool\n</code></pre> <p>Return whether a calibration measure is an integrated measure.</p> <p>See IntegratedMeasure.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the class of the calibration measure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether the calibration measure is an integrated measure.</p> </li> </ul> Source code in <code>src/gemseo_calibration/measures/factory.py</code> <pre><code>def is_integrated_measure(self, name: str) -&gt; bool:\n    \"\"\"Return whether a calibration measure is an integrated measure.\n\n    See\n    [IntegratedMeasure][gemseo_calibration.measures.integrated_measure.IntegratedMeasure].\n\n    Args:\n        name: The name of the class of the calibration measure.\n\n    Returns:\n        Whether the calibration measure is an integrated measure.\n    \"\"\"\n    return issubclass(self.get_class(name), IntegratedMeasure)\n</code></pre>"},{"location":"reference/gemseo_calibration/measures/iae/","title":"Iae","text":""},{"location":"reference/gemseo_calibration/measures/iae/#gemseo_calibration.measures.iae","title":"iae","text":"<p>Compute the integrated absolute error between the model and reference output data.</p>"},{"location":"reference/gemseo_calibration/measures/iae/#gemseo_calibration.measures.iae-classes","title":"Classes","text":""},{"location":"reference/gemseo_calibration/measures/iae/#gemseo_calibration.measures.iae.IAE","title":"IAE","text":"<pre><code>IAE(\n    output_name: str,\n    mesh_name: str,\n    name: str = \"\",\n    f_type: FunctionType = CalibrationMeasure.FunctionType.NONE,\n)\n</code></pre> <p>               Bases: <code>IntegratedMeasure</code></p> <p>The integrated absolute error between the model and reference output data.</p> <p>Parameters:</p> <ul> <li> <code>mesh_name</code>               (<code>str</code>)           \u2013            <p>The name of the 1D mesh.</p> </li> </ul> Source code in <code>src/gemseo_calibration/measures/integrated_measure.py</code> <pre><code>def __init__(\n    self,\n    output_name: str,\n    mesh_name: str,\n    name: str = \"\",\n    f_type: CalibrationMeasure.FunctionType = CalibrationMeasure.FunctionType.NONE,\n) -&gt; None:\n    \"\"\"\n    Args:\n        mesh_name: The name of the 1D mesh.\n    \"\"\"  # noqa: D205 D212 D415\n    self.mesh_name = mesh_name\n    self.__reference_mesh = None\n    super().__init__(output_name, name=name, f_type=f_type)\n</code></pre>"},{"location":"reference/gemseo_calibration/measures/iae/#gemseo_calibration.measures.iae.IAE-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/measures/iae/#gemseo_calibration.measures.iae.IAE.full_output_name","title":"full_output_name  <code>property</code>","text":"<pre><code>full_output_name: str\n</code></pre> <p>The full name of the output.</p>"},{"location":"reference/gemseo_calibration/measures/iae/#gemseo_calibration.measures.iae.IAE.maximize","title":"maximize  <code>class-attribute</code>","text":"<pre><code>maximize: bool = False\n</code></pre> <p>Whether to maximize the calibration measure.</p>"},{"location":"reference/gemseo_calibration/measures/iae/#gemseo_calibration.measures.iae.IAE.mesh_name","title":"mesh_name  <code>instance-attribute</code>","text":"<pre><code>mesh_name: str = mesh_name\n</code></pre> <p>The name of the 1D mesh.</p>"},{"location":"reference/gemseo_calibration/measures/iae/#gemseo_calibration.measures.iae.IAE.output_name","title":"output_name  <code>instance-attribute</code>","text":"<pre><code>output_name: str = output_name\n</code></pre> <p>The name of the output used by the measure for calibration.</p>"},{"location":"reference/gemseo_calibration/measures/iae/#gemseo_calibration.measures.iae.IAE-functions","title":"Functions","text":""},{"location":"reference/gemseo_calibration/measures/iae/#gemseo_calibration.measures.iae.IAE.set_reference_data","title":"set_reference_data","text":"<pre><code>set_reference_data(reference_dataset: DataType) -&gt; None\n</code></pre> <p>Define the reference input-output data set.</p> <p>Parameters:</p> <ul> <li> <code>reference_dataset</code>               (<code>DataType</code>)           \u2013            <p>The reference input-output data set.</p> </li> </ul> Source code in <code>src/gemseo_calibration/measures/integrated_measure.py</code> <pre><code>def set_reference_data(self, reference_dataset: DataType) -&gt; None:  # noqa: D102\n    self.__reference_mesh = reference_dataset[self.mesh_name]\n    super().set_reference_data(reference_dataset)\n</code></pre>"},{"location":"reference/gemseo_calibration/measures/integrated_measure/","title":"Integrated measure","text":""},{"location":"reference/gemseo_calibration/measures/integrated_measure/#gemseo_calibration.measures.integrated_measure","title":"integrated_measure","text":"<p>A module to compute the integrated measure between two data sets.</p>"},{"location":"reference/gemseo_calibration/measures/integrated_measure/#gemseo_calibration.measures.integrated_measure-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/measures/integrated_measure/#gemseo_calibration.measures.integrated_measure-classes","title":"Classes","text":""},{"location":"reference/gemseo_calibration/measures/integrated_measure/#gemseo_calibration.measures.integrated_measure.IntegratedMeasure","title":"IntegratedMeasure","text":"<pre><code>IntegratedMeasure(\n    output_name: str,\n    mesh_name: str,\n    name: str = \"\",\n    f_type: FunctionType = CalibrationMeasure.FunctionType.NONE,\n)\n</code></pre> <p>               Bases: <code>CalibrationMeasure</code></p> <p>An abstract integrated measure between two output data sets.</p> <p>Parameters:</p> <ul> <li> <code>mesh_name</code>               (<code>str</code>)           \u2013            <p>The name of the 1D mesh.</p> </li> </ul> Source code in <code>src/gemseo_calibration/measures/integrated_measure.py</code> <pre><code>def __init__(\n    self,\n    output_name: str,\n    mesh_name: str,\n    name: str = \"\",\n    f_type: CalibrationMeasure.FunctionType = CalibrationMeasure.FunctionType.NONE,\n) -&gt; None:\n    \"\"\"\n    Args:\n        mesh_name: The name of the 1D mesh.\n    \"\"\"  # noqa: D205 D212 D415\n    self.mesh_name = mesh_name\n    self.__reference_mesh = None\n    super().__init__(output_name, name=name, f_type=f_type)\n</code></pre>"},{"location":"reference/gemseo_calibration/measures/integrated_measure/#gemseo_calibration.measures.integrated_measure.IntegratedMeasure-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/measures/integrated_measure/#gemseo_calibration.measures.integrated_measure.IntegratedMeasure.full_output_name","title":"full_output_name  <code>property</code>","text":"<pre><code>full_output_name: str\n</code></pre> <p>The full name of the output.</p>"},{"location":"reference/gemseo_calibration/measures/integrated_measure/#gemseo_calibration.measures.integrated_measure.IntegratedMeasure.maximize","title":"maximize  <code>class-attribute</code>","text":"<pre><code>maximize: bool = False\n</code></pre> <p>Whether to maximize the calibration measure.</p>"},{"location":"reference/gemseo_calibration/measures/integrated_measure/#gemseo_calibration.measures.integrated_measure.IntegratedMeasure.mesh_name","title":"mesh_name  <code>instance-attribute</code>","text":"<pre><code>mesh_name: str = mesh_name\n</code></pre> <p>The name of the 1D mesh.</p>"},{"location":"reference/gemseo_calibration/measures/integrated_measure/#gemseo_calibration.measures.integrated_measure.IntegratedMeasure.output_name","title":"output_name  <code>instance-attribute</code>","text":"<pre><code>output_name: str = output_name\n</code></pre> <p>The name of the output used by the measure for calibration.</p>"},{"location":"reference/gemseo_calibration/measures/integrated_measure/#gemseo_calibration.measures.integrated_measure.IntegratedMeasure-functions","title":"Functions","text":""},{"location":"reference/gemseo_calibration/measures/integrated_measure/#gemseo_calibration.measures.integrated_measure.IntegratedMeasure.set_reference_data","title":"set_reference_data","text":"<pre><code>set_reference_data(reference_dataset: DataType) -&gt; None\n</code></pre> <p>Define the reference input-output data set.</p> <p>Parameters:</p> <ul> <li> <code>reference_dataset</code>               (<code>DataType</code>)           \u2013            <p>The reference input-output data set.</p> </li> </ul> Source code in <code>src/gemseo_calibration/measures/integrated_measure.py</code> <pre><code>def set_reference_data(self, reference_dataset: DataType) -&gt; None:  # noqa: D102\n    self.__reference_mesh = reference_dataset[self.mesh_name]\n    super().set_reference_data(reference_dataset)\n</code></pre>"},{"location":"reference/gemseo_calibration/measures/ise/","title":"Ise","text":""},{"location":"reference/gemseo_calibration/measures/ise/#gemseo_calibration.measures.ise","title":"ise","text":"<p>Compute the integrated square error between the model and reference output data.</p>"},{"location":"reference/gemseo_calibration/measures/ise/#gemseo_calibration.measures.ise-classes","title":"Classes","text":""},{"location":"reference/gemseo_calibration/measures/ise/#gemseo_calibration.measures.ise.ISE","title":"ISE","text":"<pre><code>ISE(\n    output_name: str,\n    mesh_name: str,\n    name: str = \"\",\n    f_type: FunctionType = CalibrationMeasure.FunctionType.NONE,\n)\n</code></pre> <p>               Bases: <code>IntegratedMeasure</code></p> <p>The integrated square error between the model and reference output data.</p> <p>Parameters:</p> <ul> <li> <code>mesh_name</code>               (<code>str</code>)           \u2013            <p>The name of the 1D mesh.</p> </li> </ul> Source code in <code>src/gemseo_calibration/measures/integrated_measure.py</code> <pre><code>def __init__(\n    self,\n    output_name: str,\n    mesh_name: str,\n    name: str = \"\",\n    f_type: CalibrationMeasure.FunctionType = CalibrationMeasure.FunctionType.NONE,\n) -&gt; None:\n    \"\"\"\n    Args:\n        mesh_name: The name of the 1D mesh.\n    \"\"\"  # noqa: D205 D212 D415\n    self.mesh_name = mesh_name\n    self.__reference_mesh = None\n    super().__init__(output_name, name=name, f_type=f_type)\n</code></pre>"},{"location":"reference/gemseo_calibration/measures/ise/#gemseo_calibration.measures.ise.ISE-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/measures/ise/#gemseo_calibration.measures.ise.ISE.full_output_name","title":"full_output_name  <code>property</code>","text":"<pre><code>full_output_name: str\n</code></pre> <p>The full name of the output.</p>"},{"location":"reference/gemseo_calibration/measures/ise/#gemseo_calibration.measures.ise.ISE.maximize","title":"maximize  <code>class-attribute</code>","text":"<pre><code>maximize: bool = False\n</code></pre> <p>Whether to maximize the calibration measure.</p>"},{"location":"reference/gemseo_calibration/measures/ise/#gemseo_calibration.measures.ise.ISE.mesh_name","title":"mesh_name  <code>instance-attribute</code>","text":"<pre><code>mesh_name: str = mesh_name\n</code></pre> <p>The name of the 1D mesh.</p>"},{"location":"reference/gemseo_calibration/measures/ise/#gemseo_calibration.measures.ise.ISE.output_name","title":"output_name  <code>instance-attribute</code>","text":"<pre><code>output_name: str = output_name\n</code></pre> <p>The name of the output used by the measure for calibration.</p>"},{"location":"reference/gemseo_calibration/measures/ise/#gemseo_calibration.measures.ise.ISE-functions","title":"Functions","text":""},{"location":"reference/gemseo_calibration/measures/ise/#gemseo_calibration.measures.ise.ISE.set_reference_data","title":"set_reference_data","text":"<pre><code>set_reference_data(reference_dataset: DataType) -&gt; None\n</code></pre> <p>Define the reference input-output data set.</p> <p>Parameters:</p> <ul> <li> <code>reference_dataset</code>               (<code>DataType</code>)           \u2013            <p>The reference input-output data set.</p> </li> </ul> Source code in <code>src/gemseo_calibration/measures/integrated_measure.py</code> <pre><code>def set_reference_data(self, reference_dataset: DataType) -&gt; None:  # noqa: D102\n    self.__reference_mesh = reference_dataset[self.mesh_name]\n    super().set_reference_data(reference_dataset)\n</code></pre>"},{"location":"reference/gemseo_calibration/measures/mae/","title":"Mae","text":""},{"location":"reference/gemseo_calibration/measures/mae/#gemseo_calibration.measures.mae","title":"mae","text":"<p>Compute the mean absolute error between the model and reference output data.</p>"},{"location":"reference/gemseo_calibration/measures/mae/#gemseo_calibration.measures.mae-classes","title":"Classes","text":""},{"location":"reference/gemseo_calibration/measures/mae/#gemseo_calibration.measures.mae.MAE","title":"MAE","text":"<pre><code>MAE(\n    output_name: str,\n    name: str = \"\",\n    f_type: FunctionType = MDOFunction.FunctionType.NONE,\n)\n</code></pre> <p>               Bases: <code>MeanMeasure</code></p> <p>The mean absolute error between the model and reference output data.</p> <p>Parameters:</p> <ul> <li> <code>output_name</code>               (<code>str</code>)           \u2013            <p>The name of the output to be taken into account by the measure.</p> </li> </ul> Source code in <code>src/gemseo_calibration/measure.py</code> <pre><code>def __init__(\n    self,\n    output_name: str,\n    name: str = \"\",\n    f_type: MDOFunction.FunctionType = MDOFunction.FunctionType.NONE,\n) -&gt; None:\n    \"\"\"\n    Args:\n        output_name: The name of the output to be taken into account by the measure.\n    \"\"\"  # noqa: D205,D212,D415\n    self.output_name = output_name\n    super().__init__(\n        self._evaluate_measure, name or self._compute_name(), f_type=f_type\n    )\n    self._lower_bound = -inf\n    self._upper_bound = inf\n    self._reference_data = []\n</code></pre>"},{"location":"reference/gemseo_calibration/measures/mae/#gemseo_calibration.measures.mae.MAE-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/measures/mae/#gemseo_calibration.measures.mae.MAE.full_output_name","title":"full_output_name  <code>property</code>","text":"<pre><code>full_output_name: str\n</code></pre> <p>The full name of the output.</p>"},{"location":"reference/gemseo_calibration/measures/mae/#gemseo_calibration.measures.mae.MAE.maximize","title":"maximize  <code>class-attribute</code>","text":"<pre><code>maximize: bool = False\n</code></pre> <p>Whether to maximize the calibration measure.</p>"},{"location":"reference/gemseo_calibration/measures/mae/#gemseo_calibration.measures.mae.MAE.output_name","title":"output_name  <code>instance-attribute</code>","text":"<pre><code>output_name: str = output_name\n</code></pre> <p>The name of the output used by the measure for calibration.</p>"},{"location":"reference/gemseo_calibration/measures/mae/#gemseo_calibration.measures.mae.MAE-functions","title":"Functions","text":""},{"location":"reference/gemseo_calibration/measures/mae/#gemseo_calibration.measures.mae.MAE.set_reference_data","title":"set_reference_data","text":"<pre><code>set_reference_data(reference_dataset: DataType) -&gt; None\n</code></pre> <p>Define the reference input-output data set.</p> <p>Parameters:</p> <ul> <li> <code>reference_dataset</code>               (<code>DataType</code>)           \u2013            <p>The reference input-output data set.</p> </li> </ul> Source code in <code>src/gemseo_calibration/measure.py</code> <pre><code>def set_reference_data(self, reference_dataset: DataType) -&gt; None:\n    \"\"\"Define the reference input-output data set.\n\n    Args:\n        reference_dataset: The reference input-output data set.\n    \"\"\"\n    self._reference_data = reference_dataset[self.output_name]\n    self._lower_bound = nanmin(self._reference_data)\n    self._upper_bound = nanmax(self._reference_data)\n</code></pre>"},{"location":"reference/gemseo_calibration/measures/mean_measure/","title":"Mean measure","text":""},{"location":"reference/gemseo_calibration/measures/mean_measure/#gemseo_calibration.measures.mean_measure","title":"mean_measure","text":"<p>A module to compute the mean measure between the model and reference data.</p>"},{"location":"reference/gemseo_calibration/measures/mean_measure/#gemseo_calibration.measures.mean_measure-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/measures/mean_measure/#gemseo_calibration.measures.mean_measure-classes","title":"Classes","text":""},{"location":"reference/gemseo_calibration/measures/mean_measure/#gemseo_calibration.measures.mean_measure.MeanMeasure","title":"MeanMeasure","text":"<pre><code>MeanMeasure(\n    output_name: str,\n    name: str = \"\",\n    f_type: FunctionType = MDOFunction.FunctionType.NONE,\n)\n</code></pre> <p>               Bases: <code>CalibrationMeasure</code></p> <p>An abstract mean measure between the model and reference output data.</p> <p>Parameters:</p> <ul> <li> <code>output_name</code>               (<code>str</code>)           \u2013            <p>The name of the output to be taken into account by the measure.</p> </li> </ul> Source code in <code>src/gemseo_calibration/measure.py</code> <pre><code>def __init__(\n    self,\n    output_name: str,\n    name: str = \"\",\n    f_type: MDOFunction.FunctionType = MDOFunction.FunctionType.NONE,\n) -&gt; None:\n    \"\"\"\n    Args:\n        output_name: The name of the output to be taken into account by the measure.\n    \"\"\"  # noqa: D205,D212,D415\n    self.output_name = output_name\n    super().__init__(\n        self._evaluate_measure, name or self._compute_name(), f_type=f_type\n    )\n    self._lower_bound = -inf\n    self._upper_bound = inf\n    self._reference_data = []\n</code></pre>"},{"location":"reference/gemseo_calibration/measures/mean_measure/#gemseo_calibration.measures.mean_measure.MeanMeasure-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/measures/mean_measure/#gemseo_calibration.measures.mean_measure.MeanMeasure.full_output_name","title":"full_output_name  <code>property</code>","text":"<pre><code>full_output_name: str\n</code></pre> <p>The full name of the output.</p>"},{"location":"reference/gemseo_calibration/measures/mean_measure/#gemseo_calibration.measures.mean_measure.MeanMeasure.maximize","title":"maximize  <code>class-attribute</code>","text":"<pre><code>maximize: bool = False\n</code></pre> <p>Whether to maximize the calibration measure.</p>"},{"location":"reference/gemseo_calibration/measures/mean_measure/#gemseo_calibration.measures.mean_measure.MeanMeasure.output_name","title":"output_name  <code>instance-attribute</code>","text":"<pre><code>output_name: str = output_name\n</code></pre> <p>The name of the output used by the measure for calibration.</p>"},{"location":"reference/gemseo_calibration/measures/mean_measure/#gemseo_calibration.measures.mean_measure.MeanMeasure-functions","title":"Functions","text":""},{"location":"reference/gemseo_calibration/measures/mean_measure/#gemseo_calibration.measures.mean_measure.MeanMeasure.set_reference_data","title":"set_reference_data","text":"<pre><code>set_reference_data(reference_dataset: DataType) -&gt; None\n</code></pre> <p>Define the reference input-output data set.</p> <p>Parameters:</p> <ul> <li> <code>reference_dataset</code>               (<code>DataType</code>)           \u2013            <p>The reference input-output data set.</p> </li> </ul> Source code in <code>src/gemseo_calibration/measure.py</code> <pre><code>def set_reference_data(self, reference_dataset: DataType) -&gt; None:\n    \"\"\"Define the reference input-output data set.\n\n    Args:\n        reference_dataset: The reference input-output data set.\n    \"\"\"\n    self._reference_data = reference_dataset[self.output_name]\n    self._lower_bound = nanmin(self._reference_data)\n    self._upper_bound = nanmax(self._reference_data)\n</code></pre>"},{"location":"reference/gemseo_calibration/measures/mse/","title":"Mse","text":""},{"location":"reference/gemseo_calibration/measures/mse/#gemseo_calibration.measures.mse","title":"mse","text":"<p>Compute the mean square error between the model and reference output data.</p>"},{"location":"reference/gemseo_calibration/measures/mse/#gemseo_calibration.measures.mse-classes","title":"Classes","text":""},{"location":"reference/gemseo_calibration/measures/mse/#gemseo_calibration.measures.mse.MSE","title":"MSE","text":"<pre><code>MSE(\n    output_name: str,\n    name: str = \"\",\n    f_type: FunctionType = MDOFunction.FunctionType.NONE,\n)\n</code></pre> <p>               Bases: <code>MeanMeasure</code></p> <p>The mean square error between the model and reference output data.</p> <p>Parameters:</p> <ul> <li> <code>output_name</code>               (<code>str</code>)           \u2013            <p>The name of the output to be taken into account by the measure.</p> </li> </ul> Source code in <code>src/gemseo_calibration/measure.py</code> <pre><code>def __init__(\n    self,\n    output_name: str,\n    name: str = \"\",\n    f_type: MDOFunction.FunctionType = MDOFunction.FunctionType.NONE,\n) -&gt; None:\n    \"\"\"\n    Args:\n        output_name: The name of the output to be taken into account by the measure.\n    \"\"\"  # noqa: D205,D212,D415\n    self.output_name = output_name\n    super().__init__(\n        self._evaluate_measure, name or self._compute_name(), f_type=f_type\n    )\n    self._lower_bound = -inf\n    self._upper_bound = inf\n    self._reference_data = []\n</code></pre>"},{"location":"reference/gemseo_calibration/measures/mse/#gemseo_calibration.measures.mse.MSE-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_calibration/measures/mse/#gemseo_calibration.measures.mse.MSE.full_output_name","title":"full_output_name  <code>property</code>","text":"<pre><code>full_output_name: str\n</code></pre> <p>The full name of the output.</p>"},{"location":"reference/gemseo_calibration/measures/mse/#gemseo_calibration.measures.mse.MSE.maximize","title":"maximize  <code>class-attribute</code>","text":"<pre><code>maximize: bool = False\n</code></pre> <p>Whether to maximize the calibration measure.</p>"},{"location":"reference/gemseo_calibration/measures/mse/#gemseo_calibration.measures.mse.MSE.output_name","title":"output_name  <code>instance-attribute</code>","text":"<pre><code>output_name: str = output_name\n</code></pre> <p>The name of the output used by the measure for calibration.</p>"},{"location":"reference/gemseo_calibration/measures/mse/#gemseo_calibration.measures.mse.MSE-functions","title":"Functions","text":""},{"location":"reference/gemseo_calibration/measures/mse/#gemseo_calibration.measures.mse.MSE.set_reference_data","title":"set_reference_data","text":"<pre><code>set_reference_data(reference_dataset: DataType) -&gt; None\n</code></pre> <p>Define the reference input-output data set.</p> <p>Parameters:</p> <ul> <li> <code>reference_dataset</code>               (<code>DataType</code>)           \u2013            <p>The reference input-output data set.</p> </li> </ul> Source code in <code>src/gemseo_calibration/measure.py</code> <pre><code>def set_reference_data(self, reference_dataset: DataType) -&gt; None:\n    \"\"\"Define the reference input-output data set.\n\n    Args:\n        reference_dataset: The reference input-output data set.\n    \"\"\"\n    self._reference_data = reference_dataset[self.output_name]\n    self._lower_bound = nanmin(self._reference_data)\n    self._upper_bound = nanmax(self._reference_data)\n</code></pre>"},{"location":"reference/gemseo_calibration/post/","title":"Post","text":""},{"location":"reference/gemseo_calibration/post/#gemseo_calibration.post","title":"post","text":"<p>The post-processing methods for the calibration scenarios.</p>"},{"location":"reference/gemseo_calibration/post/factory/","title":"Factory","text":""},{"location":"reference/gemseo_calibration/post/factory/#gemseo_calibration.post.factory","title":"factory","text":"<p>A factory to post-process a <code>CalibrationScenario</code>.</p>"},{"location":"reference/gemseo_calibration/post/factory/#gemseo_calibration.post.factory-classes","title":"Classes","text":""},{"location":"reference/gemseo_calibration/post/factory/#gemseo_calibration.post.factory.CalibrationPostFactory","title":"CalibrationPostFactory","text":"<p>               Bases: <code>OptPostProcessorFactory</code></p> <p>A factory for calibration post-processing.</p>"},{"location":"reference/gemseo_calibration/post/factory/#gemseo_calibration.post.factory.CalibrationPostFactory-functions","title":"Functions","text":""},{"location":"reference/gemseo_calibration/post/factory/#gemseo_calibration.post.factory.CalibrationPostFactory.create","title":"create","text":"<pre><code>create(\n    post_name: str,\n    opt_problem: OptimizationProblem,\n    reference_data: Dataset,\n    prior_model_data: Dataset,\n    posterior_model_data: Dataset,\n) -&gt; CalibrationPostProcessor\n</code></pre> <p>Create the post-processing.</p> <p>Parameters:</p> <ul> <li> <code>post_name</code>               (<code>str</code>)           \u2013            <p>The name of the post-processing method.</p> </li> <li> <code>opt_problem</code>               (<code>OptimizationProblem</code>)           \u2013            <p>The optimization problem containing the data to post-process.</p> </li> <li> <code>reference_data</code>               (<code>Dataset</code>)           \u2013            <p>The reference data used during the calibration stage.</p> </li> <li> <code>prior_model_data</code>               (<code>Dataset</code>)           \u2013            <p>The model data before the calibration stage.</p> </li> <li> <code>posterior_model_data</code>               (<code>Dataset</code>)           \u2013            <p>The model data after the calibration stage.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CalibrationPostProcessor</code>           \u2013            <p>The post-processing of the optimization problem.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the class cannot be instantiated.</p> </li> </ul> Source code in <code>src/gemseo_calibration/post/factory.py</code> <pre><code>def create(\n    self,\n    post_name: str,\n    opt_problem: OptimizationProblem,\n    reference_data: Dataset,\n    prior_model_data: Dataset,\n    posterior_model_data: Dataset,\n) -&gt; CalibrationPostProcessor:\n    \"\"\"Create the post-processing.\n\n    Args:\n        opt_problem: The optimization problem containing the data to post-process.\n        reference_data: The reference data used during the calibration stage.\n        prior_model_data: The model data before the calibration stage.\n        posterior_model_data: The model data after the calibration stage.\n        post_name: The name of the post-processing method.\n\n    Returns:\n        The post-processing of the optimization problem.\n    \"\"\"\n    return super().create(\n        post_name,\n        reference_data=reference_data,\n        prior_model_data=prior_model_data,\n        posterior_model_data=posterior_model_data,\n        opt_problem=opt_problem,\n    )\n</code></pre>"},{"location":"reference/gemseo_calibration/post/factory/#gemseo_calibration.post.factory.CalibrationPostFactory.execute","title":"execute","text":"<pre><code>execute(\n    opt_problem: str | OptimizationProblem,\n    reference_data: Dataset,\n    prior_model_data: Dataset,\n    posterior_model_data: Dataset,\n    post_name: str,\n    save: bool = True,\n    show: bool = False,\n    file_path: str | Path = \"\",\n    directory_path: str | Path = \"\",\n    file_name: str = \"\",\n    file_extension: str = \"\",\n    **options: Any\n) -&gt; CalibrationPostProcessor\n</code></pre> <p>Compute the post-processing.</p> <p>Parameters:</p> <ul> <li> <code>opt_problem</code>               (<code>str | OptimizationProblem</code>)           \u2013            <p>The optimization problem containing the data to post-process.</p> </li> <li> <code>reference_data</code>               (<code>Dataset</code>)           \u2013            <p>The reference data used during the calibration stage.</p> </li> <li> <code>prior_model_data</code>               (<code>Dataset</code>)           \u2013            <p>The model data before the calibration stage.</p> </li> <li> <code>posterior_model_data</code>               (<code>Dataset</code>)           \u2013            <p>The model data after the calibration stage.</p> </li> <li> <code>post_name</code>               (<code>str</code>)           \u2013            <p>The name of the post-processing method.</p> </li> <li> <code>save</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to save the figure.</p> </li> <li> <code>show</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to display the figure.</p> </li> <li> <code>file_path</code>               (<code>str | Path</code>, default:                   <code>''</code> )           \u2013            <p>The path of the file to save the figures. If the extension is missing, use <code>file_extension</code>. If empty, create a file path from <code>directory_path</code>, <code>file_name</code> and <code>file_extension</code>.</p> </li> <li> <code>directory_path</code>               (<code>str | Path</code>, default:                   <code>''</code> )           \u2013            <p>The path of the directory to save the figures. If empty, use the current working directory.</p> </li> <li> <code>file_name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The name of the file to save the figures. If empty, use a default one generated by the post-processing.</p> </li> <li> <code>file_extension</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>A file extension, e.g. 'png', 'pdf', 'svg', ... If empty, use a default file extension.</p> </li> <li> <code>**options</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>The options of the post-processor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CalibrationPostProcessor</code>           \u2013            <p>The executed post-processing of the optimization problem.</p> </li> </ul> Source code in <code>src/gemseo_calibration/post/factory.py</code> <pre><code>def execute(\n    self,\n    opt_problem: str | OptimizationProblem,\n    reference_data: Dataset,\n    prior_model_data: Dataset,\n    posterior_model_data: Dataset,\n    post_name: str,\n    save: bool = True,\n    show: bool = False,\n    file_path: str | Path = \"\",\n    directory_path: str | Path = \"\",\n    file_name: str = \"\",\n    file_extension: str = \"\",\n    **options: Any,\n) -&gt; CalibrationPostProcessor:\n    \"\"\"Compute the post-processing.\n\n    Args:\n        opt_problem: The optimization problem containing the data to post-process.\n        reference_data: The reference data used during the calibration stage.\n        prior_model_data: The model data before the calibration stage.\n        posterior_model_data: The model data after the calibration stage.\n        post_name: The name of the post-processing method.\n        save: Whether to save the figure.\n        show: Whether to display the figure.\n        file_path: The path of the file to save the figures.\n            If the extension is missing, use `file_extension`.\n            If empty,\n            create a file path\n            from `directory_path`, `file_name` and `file_extension`.\n        directory_path: The path of the directory to save the figures.\n            If empty, use the current working directory.\n        file_name: The name of the file to save the figures.\n            If empty, use a default one generated by the post-processing.\n        file_extension: A file extension, e.g. 'png', 'pdf', 'svg', ...\n            If empty, use a default file extension.\n        **options: The options of the post-processor.\n\n    Returns:\n        The executed post-processing of the optimization problem.\n    \"\"\"\n    if isinstance(opt_problem, str):\n        opt_problem = OptimizationProblem.from_hdf(opt_problem)\n    post = self.create(\n        post_name,\n        opt_problem,\n        reference_data,\n        prior_model_data,\n        posterior_model_data,\n    )\n    post.execute(\n        save=save,\n        show=show,\n        file_path=file_path or None,\n        directory_path=directory_path or None,\n        file_name=file_name or None,\n        file_extension=file_extension or None,\n        **options,\n    )\n    self.executed_post.append(post)\n    return post\n</code></pre>"},{"location":"reference/gemseo_calibration/post/multiple_scatter/","title":"Multiple scatter","text":""},{"location":"reference/gemseo_calibration/post/multiple_scatter/#gemseo_calibration.post.multiple_scatter","title":"multiple_scatter","text":"<p>Overlay several scatter plots from a <code>Dataset</code>.</p> <p>A scatter plot represents a set of points \\(\\{x_i,y_i\\}_{1\\leq i \\leq n}\\) as markers on a classical plot, while a multiple-scatter plot represents a set of points \\(\\{x_i,y_{i,1},\\ldots,y_{i,d}\\}_{1\\leq i \\leq n}\\) as markers on a classical plot, with one color per series \\(\\{y_i\\}_{1\\leq i \\leq n}\\).</p>"},{"location":"reference/gemseo_calibration/post/multiple_scatter/#gemseo_calibration.post.multiple_scatter-classes","title":"Classes","text":""},{"location":"reference/gemseo_calibration/post/multiple_scatter/#gemseo_calibration.post.multiple_scatter.MultipleScatter","title":"MultipleScatter","text":"<pre><code>MultipleScatter(\n    dataset: Dataset,\n    x: str,\n    y: str | Iterable[str],\n    x_comp: int = 0,\n    y_comp: Mapping[str, int] = MappingProxyType({}),\n)\n</code></pre> <p>               Bases: <code>DatasetPlot</code></p> <p>Overlay several scatter y_i versus x.</p> <p>Parameters:</p> <ul> <li> <code>dataset</code>               (<code>Dataset</code>)           \u2013            <p>The dataset containing the data to plot.</p> </li> <li> <code>x</code>               (<code>str</code>)           \u2013            <p>The name of the variable on the x-axis.</p> </li> <li> <code>y</code>               (<code>str | Iterable[str]</code>)           \u2013            <p>The names of the variables on the y-axis.</p> </li> <li> <code>x_comp</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The component of x.</p> </li> <li> <code>y_comp</code>               (<code>Mapping[str, int]</code>, default:                   <code>MappingProxyType({})</code> )           \u2013            <p>The components of y, where the names are the names of the variables and the values are the components. If empty or if a name is missing, use the first component.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the dataset is empty.</p> </li> </ul> Source code in <code>src/gemseo_calibration/post/multiple_scatter.py</code> <pre><code>def __init__(\n    self,\n    dataset: Dataset,\n    x: str,\n    y: str | Iterable[str],\n    x_comp: int = 0,\n    y_comp: Mapping[str, int] = MappingProxyType({}),\n) -&gt; None:\n    \"\"\"\n    Args:\n        x: The name of the variable on the x-axis.\n        y: The names of the variables on the y-axis.\n        x_comp: The component of x.\n        y_comp: The components of y,\n            where the names are the names of the variables\n            and the values are the components.\n            If empty or if a name is missing,\n            use the first component.\n    \"\"\"  # noqa: D205 D212 D415\n    super().__init__(dataset=dataset, x=x, y=y, x_comp=x_comp, y_comp=y_comp)\n</code></pre>"},{"location":"reference/gemseo_calibration/post/data_versus_model/","title":"Data versus model","text":""},{"location":"reference/gemseo_calibration/post/data_versus_model/#gemseo_calibration.post.data_versus_model","title":"data_versus_model","text":"<p>Method to plot model data versus reference ones.</p>"},{"location":"reference/gemseo_calibration/post/data_versus_model/post/","title":"Post","text":""},{"location":"reference/gemseo_calibration/post/data_versus_model/post/#gemseo_calibration.post.data_versus_model.post","title":"post","text":"<p>Plot the model data versus the reference data.</p>"},{"location":"reference/gemseo_calibration/post/data_versus_model/post/#gemseo_calibration.post.data_versus_model.post-classes","title":"Classes","text":""},{"location":"reference/gemseo_calibration/post/data_versus_model/post/#gemseo_calibration.post.data_versus_model.post.DataVersusModel","title":"DataVersusModel","text":"<pre><code>DataVersusModel(\n    opt_problem: OptimizationProblem,\n    reference_data: DataType,\n    prior_model_data: DataType,\n    posterior_model_data: DataType,\n)\n</code></pre> <p>               Bases: <code>CalibrationPostProcessor</code></p> <p>Scatter plot of the model data versus the reference ones.</p> <p>Parameters:</p> <ul> <li> <code>opt_problem</code>               (<code>OptimizationProblem</code>)           \u2013            <p>The optimization problem to run.</p> </li> <li> <code>reference_data</code>               (<code>DataType</code>)           \u2013            <p>The reference data.</p> </li> <li> <code>prior_model_data</code>               (<code>DataType</code>)           \u2013            <p>The model data before the calibration.</p> </li> <li> <code>posterior_model_data</code>               (<code>DataType</code>)           \u2013            <p>The model data after the calibration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the JSON grammar file for the options of the post-processor does not exist.</p> </li> </ul> Source code in <code>src/gemseo_calibration/post_processor.py</code> <pre><code>def __init__(\n    self,\n    opt_problem: OptimizationProblem,\n    reference_data: DataType,\n    prior_model_data: DataType,\n    posterior_model_data: DataType,\n) -&gt; None:\n    \"\"\"\n    Args:\n        opt_problem: The optimization problem to run.\n        reference_data: The reference data.\n        prior_model_data: The model data before the calibration.\n        posterior_model_data: The model data after the calibration.\n    \"\"\"  # noqa: D205, D212, D415\n    super().__init__(opt_problem)\n    self._reference_data = reference_data\n    self._prior_model_data = prior_model_data\n    self._posterior_model_data = posterior_model_data\n</code></pre>"},{"location":"user_guide/","title":"User guide","text":""},{"location":"user_guide/#user-guide","title":"User guide","text":""}]}